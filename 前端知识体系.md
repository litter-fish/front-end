# 前端知识体系

## 基础

### CSS

- css 盒模型

	- 组成

		- 左外边距（margin-left）+ 左边框（border-left）+ 左内边距（padding-left）+ width + 右内边距（padding-right）+ 右边框（border-right）+ 右外边距（margin-right) = 父元素的width
		- 只有元素内容区（width）、外边距可以设置成auto，其他值要么设置成具体值，要么使用默认值0

			- 如果三个都被设置成非auto，则margin-right会被强制设置成auto；
			- 如果三个值都被设置成auto，则两侧的外边距都会被设置成0；

	- 分类

		- 标准盒模型
		- 非标准盒模型（IE盒模型）

	- box-sizing

		- content-box：W3C的标准模型，
		- padding-box：宽度包括padding值
		- border-box：宽度包括padding和border

- bfc

	- 什么是BFC？

		- 块级格式上下文，web页面中盒模型布局的CSS渲染模式，指一个独立的渲染区域

	- 触发条件

		- 浮动元素

			- float值不为none

		- 定位元素

			- position值为absolute、fixed

		- overflow 属性

			- 值不是 visible 的块元素

		- display属性

			- inline-block、table-cell、table-caption、flow-root

	- 约束规则

		- 内部元素垂直方向上会一个挨着一个放置
		- BFC的区域不会与浮动元素重叠
		- 计算BFC的高度时也会将浮动元素计算上

	- 解决问题

		- 两栏布局
		- 解决“高度塌陷”

			- 解决办法？

				- 使用带`clear`属性的空元素

				  ```
				  <div style="">
				  	<div style="height: 100px;width: 100px;float: left;">float: left</div>
					<!-- height: 0;overflow: hidden; 为了解决 IE 浏览器的兼容问题 -->
					<div style="height: 0;overflow: hidden;clear: both;"></div>
				  </div>
				  ```
				  
					- 原理

						- 在浮动元素后面定义一个空的元素，设置`clear`属性

					- clear 属性清除浮动的原理

						- 设置了 clear 的元素只能通过调整自身来使自己不要和浮动元素排列在一起
						- 如果一个元素同时设置了 float:left 和 clear:left，希望左边不要有浮动元素，那么这个元素就要调整自己，排到下一行去。因为设置了 float: left，这个元素会往左边靠拢，所以这个元素会跑到下一行，同时往左浮动。

				- 伪元素`::after`

				    ```
					.clearfix::after {
						content: '';
						display: block;
						clear: both;
						/* height: 0;overflow: hidden; 为了解决 IE 浏览器的兼容问题 */
						height: 0;
						overflow: hidden;
						/* visibility:hidden;为了去隐藏content中的内容 */
						visibility: hidden;
					}
					<div style="clearfix">
						<div style="height: 100px;width: 100px;float: left;">float: left</div>
					</div>
					```
				  
					- 原理

						- 在浮动元素的包含框中添加一个`::after`伪元素，添加一个看不见的块元素清除浮动

				- 包含框添加 `overflow: hidden` 或 `overflow:auto；`

				    ```
					<div style="overflow:auto">
						<div style="height: 100px;width: 100px;float: left;">float: left</div>
					</div>
					```
				  
					- 原理

						- bfc

				- 设置浮动框的包含框为浮动元素

					```
					<div style="float: left;">
						<div style="height: 100px;width: 100px;float: left;">float: left</div>
					</div>
					```
				  
					- 原理

- 层叠上下文

	- 元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。
	- 层叠准则

		- 谁大谁上

			- 同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个

		- 后来居上

			- 当元素的层叠水平一致、层叠顺序相同的时候，在DOM流中处于后面的元素会覆盖前面的元素

	- 触发条件

		- 根层叠上下文(html)
		- 定位元素与传统层叠上下文

			- position:relative/position:absolute，当其z-index值不是auto
			- Chrome等webkit内核浏览器

				- position:fixed元素天然层叠上下文元素，无需z-index为数值

			- FireFox/IE浏览器

				- position:fixed声明的定位元素，当其z-index值不是auto的时候，会创建层叠上下文

		- css3属性

			- flex（子元素为层叠上下文元素）

				```
				/* 此时该div是层叠上下文元素，同时z-index生效 */
				<div class="box">
					<div>
						<img src="mm1.jpg">
					</div>
				</div>
				
				.box { display: flex; } // 父级元素 flex
				.box > div { background-color: blue; z-index: 1; } // 子元素的z-index不为auto
				.box > div > img {
				position: relative; z-index: -1; right: -150px;     /* 注意这里是负值z-index */
				}
				```
			  
				- 父级需要是display:flex或者display:inline-flex水平
				- 子元素的z-index不是auto，必须是数值

			- transform
			- opacity

				```
				// opacity属性使得div形成层叠上下文，background-color的顺序比负的z-index低
				<div class="box">
					<img src="mm1.jpg">
				</div>
				
				.box { background-color: blue; opacity: 0.5;  }
				.box > img {
				position: relative; z-index: -1; right: -150px;
				}
				```
			  
				- opacity 值不为1的元素形成层叠上下文

			- filter
			- will-change
			- -webkit-overflow-scrolling
			-  mix-blend-mode

	- 层叠等级

		- 正z-index
		- z-index:auto或看出z-index:0、不依赖z-index的层叠上下文
		- inline、inline-block水平盒子
		- float浮动盒子
		- block块状水平盒子
		- 负z-index
		- 层叠上下文 background、border

- 伪类和伪元素
- css选择器

	- 类别

		- ID 选择符

			- #id {}

		- 类选择符

			- .clazz {}

		- 属性选择符

			- input[type='number'] {}
			- 部分值

				- |=  包含词组或包含词组-
				- ~=  包含词组
				- *=  包含子串
				- ^=  匹配开头
				- $=  匹配结尾

		- 伪类选择符

			- :only-child 唯一的子代

				- `a[href] img:only-child {}` 存在href属性的a标签，且只有唯一的一个子元素img

			- :only-of-type 同胞中唯一的元素

				- `a[href] img:only-of-type {}` 存在href属性的a标签，且存在多个子元素但只有一个img元素

			- :first-child 第一个元素

				- p:first-child - 匹配第一个p元素

			- :in-rang - 输入的值在min和max之间
			- :last-child
			- :nth-child(n)

		- 元素选择符

			- div {}

		- 伪元素选择符

			- ::first-letter 匹配非行内元素的首字母
			- ::before 作用元素前面
			- ::after 作用元素后面
			- ::first-line 匹配元素首行文本

		- 文档结构选择符

			- 空格  后代选择
			- >    子元素
			- +    相邻同胞
			- ~    后续同胞

	- 优先级

		- 由四个值组成，如0,0,0,0
		- !important值始终胜出
		- 行内声明的样式值为：1,0,0,0
		- ID选择符值为：0,1,0,0
		- 类选择符、属性选择符、伪类选择符值为：0,0,1,0
		- 元素选择符、伪元素选择符值为：0,0,0,1
		- 文档结构选择符值为： 0,0,0,0

- CSS 定位机制

	- 普通流

		- 所有框都是普通流，除非进行声明，位置有HTML声明时确定

	- 浮动

		- 设置float属性，使浮动框向左或向右移动，直到边框或其他浮动框的边缘
		- 脱离文档流

	- position

		- relative

			- 设置top/left/right/bottom属性使元素框相对于文档初始位置偏移一定距离
			- 保留文档空间

		- absolute

			- 相对于包含块进行定位

				- 最近已定位的祖先元素

					- 祖辈元素是块级元素

						- 容纳块是这个元素的内边距边界

					- 祖辈元素是行内元素

						- 容纳块是祖辈元素的内容边界

					- 如果没有祖先元素则容纳块是初始容纳块。

				- 初始包含块

			- 脱离文档流
			- 特性

				- 包裹性

					- 让元素inline-block化
					- div标签默认宽度是100%显示，但是一旦被absolute属性缠上，则100%默认宽度就会变成自适应内部元素的宽度

				- 破坏性

					- 高度塌陷

		- fixed

- 布局方式

	- flex

		- 弹性盒布局，由Flex容器和Flex弹性元素组成，容器存在主轴和交叉轴
		- 容器中的属性

			- 主轴相关

				- 设置主轴的方向`flex-direction`
				- `flex-flow` - `flex-direction`和`flex-warp`属性的简写
				- 设置弹性元素在主轴上的对齐方式`justify-content`

					- flex-start

						- 弹性元素紧靠着主轴起边；

					- flex-end

						- 弹性元素紧靠着主轴终边；

					- center

						- 弹性元素作为一个整体居中显示在主轴尺寸的中点；

					- space-between

						- 一行的第一个弹性元素靠近主轴的起边，最后一个元素靠近终边，然后在各弹性元素周围放置等量的空白（剩余空间 / (n - 1）)；

					- space-around

						- 将一行中额外的空白均匀分布在各弹性元素的周围，如果不允许换行且内容出现溢出，则弹性元素将从两端溢出；

					- space-evenly

						- 将剩余空间分成（弹性元素个数+1）份，相邻元素距离相同，如果不允许换行且内容出现溢出，则弹性元素将从两端溢出；

			- 垂轴相关

				- 项目在交叉轴上的对齐方式`align-items`

					- stretch
					- flex-start
					- flex-end
					- center
					- baseline

				- 设置存在多条主轴时如果在交叉轴上存在剩余空间如何进行分配`align-content`

					- stretch

						- 将额外空间分配给每一行弹性元素，而不是填充空白；

			- 共同属性

				- 设置主轴方向上是否可以换行`flex-warp`

					- nowrap
					- warp
					- warp-reverse

		- 弹性元素中的属性

			- flex-grow

				- 指定如果有剩余的空间弹性元素的增长因子，默认0，始终是一个非负数
				- 0表示弹性元素不能进行增大；非0的话将按照非0 分配剩余空间

			- flex-shrink

				- 设置弹性缩进因子，默认值为1
				- 当弹性元素需要缩减的计算规则

					- 缩小比例 = (减少的空间 / ((宽度1*缩减因子1)+...+(宽度N*缩减因子N)))
					- 弹性元素1 = 宽度1*(缩减因子1*缩小比例)

			- flex-basic

				- 定义弹性元素的初始化或默认尺寸
				- 取值

					- auto

						- 默认等于各弹性元素声明的宽度，将多余的空间按照增长因子的比例分配给弹性元素

					- 具体数字

						- 优先级比width属性高

					- 百分数

						- 值相对于弹性容器的主轴尺寸计算

					- 0

						- 将弹性容器的尺寸按照增长因子的比例分配给各个弹性元素

	- grid

		- display: grid或inline-grid
		- 网格轨道

	- float

		- float: left|right|none

			- 不管什么类型的元素，浮动后得到的都是块级框

		- 浮动元素位置的规则
		- 浮动元素与内容重叠规则

			- 行内框与浮动元素重叠，其边框、背景和内容都在浮动元素“之上”渲染；
			- 块级框与浮动元素重叠，器边框和背景在浮动元素“背后”渲染，内容在浮动元素“之上”渲染

- 两栏布局

	- flex
	- float + margin
	- float + BFC

- 三栏布局

	- 圣杯布局

		```
		<style type="text/css">
		.container {
			border: 1px solid black;
			padding-left: 100px; /*给左右padding，数值为对应左右宽度*/
			padding-right: 120px;
		}
		/* 清除浮动 */
		.clearfix:after {
		content: '';
		display: block;
		clear: both;
		}
		
		.main,.left,.right {
		float: left;
		}
		
		.main {
		background: #ccc;
		width: 100%;
		}
		
		.left {
		background: red;
		width: 100px;
		margin-left: -100%;/* 值为100%，left会在最左边 */
		position: relative;
		left: -100px; /* 相对定位，右移自身宽度 */
		}
		
		.right {
		background: blue;
		width: 120px;
		margin-left: -120px;
		position: relative;
		right: -120px; /* 相对定位，右移自身宽度 */
		}
		</style>
		<div class="container clearfix">
				<div class="main">main</div>
				<div class="left">left</div>
				<div class="right">right</div>
		</div>
		```
	  
		- 首先设置三栏的`float`值都为`left；`同时设置中间栏宽度100%，设置后中间一栏独占一行，左右两栏跑到下面一行中显示；
		- 通过设置左右的`margin-left`使得左右中间三栏处在同一行
		- 给父容器添加`padding`属性，使得宽度进行压缩
		- 使用margin设置后三栏位于同一行后会出现重叠现象，因此接着设置`position:relative`，然后向左或向右移动宽度值

	- 双飞翼布局

	  ```
	  <style>
	      .container {
	          border: 1px solid black;
	      }
	      .wrap,.left,.right {
	          float: left;
	      }
	      .wrap {
	          width: 100%;
	          background-color: blue;
	      }
	      .main {
	          margin-left: 100px;
	          margin-right: 120px;
	      }
	      .left {
	          width: 100px;
	          background-color: red;
	          margin-left: -100%;
	      }
	      .right {
	          width: 120px;
	          background-color: yellow;
	          margin-left: -120px;
	      }
	  </style>
	  <div class="container clearfix">
	      <div class="wrap">
	          <div class="main">main</div>
	      </div>
	      <div class="left">left</div>
	      <div class="right">right</div>
	  </div>
	  ```
	  
		- 首先设置三栏的`float: left;`同时设置中间栏宽度100%，设置后中间一栏独占一行，左右两栏跑到下面一行中显示；
		- 通过`margin-left`使得左右中间三栏处在同一行
		- 通过给中间的内容设置`margin`减少重叠现象

	- Flex布局

		- 设置父元素`display: flex`
		- 子元素
		```
		.left {flex: 0 0 100px}
		.right {flex: 0 0 120px}
		.main {flex: 1}
		```
		  
- 居中

	- CSS3

		- flex

		  ```
		  display: flex;
		  algin-items: center;
		  justify-content:center;
		  ```
		  
		- grid

			- margin: auto;

	- CSS2

		- 内联元素

			- 水平

				- text-algin: center

			- 垂直

				- 单行文本：line-height等于容器height
				- 多行文本：disaply: table-cell; vertical-align: middle;

		- 块级元素

			- 未知宽高

				- position+transfrom+top/left

					```
					<style type="text/css">
						.container {
							position: relative;
							width: 200px;
							height: 200px;
							background-color: blue;
						}
						.main {
							position: absolute;
							top: 50%;
							left: 50%;
							transform: translate(-50%, -50%);
							background-color: red;
						}
					</style>
					
					<div class="container">
						<div class="main">main</div>
					</div>
					```
				  
					- 父元素

						- 通过`position: relative;`设置成子元素的包含框

					- 子元素

						- 设置相对定位
						- 设置top/left偏移50%
						- top/left相对于框的左上角，所有通过`transform: translate(-50%，-50%);`使得中心点位于居中位置

			- 已知宽高

				- position + margin + left/top/right/buttom

					```
					<style type="text/css">
						.container {
							position: relative;
							width: 200px;
							height: 200px;
							background-color: blue;
						}
						.main {
							position: absolute;
							top: 0;
							left: 0;
							right: 0;
							bottom: 0;
							height: 100px;
							width: 100px;
							margin: auto;
							background-color: red;
						}
					</style>
					
					<div class="container">
						<div class="main">main</div>
					</div>
					```
				  
					- 父元素

						- 通过`position: relative;`设置成子元素的包含框

					- 子元素

						- 设置相对定位
						- left/top/right/buttom设置成0
						- 设置margin: auto;

				- position + margin-left/margin-top + left/top

					```
					<style type="text/css">
						.container {
							position: relative;
							width: 200px;
							height: 200px;
							background-color: blue;
						}
						.main {
							position: absolute;
							top: 50%;
							left: 50%;
							height: 100px;
							width: 100px;
							margin-top: -50px;
							margin-left: -50px;
							background-color: red;
						}
					</style>
					
					<div class="container">
						<div class="main">main</div>
					</div>
					```
				  
					- 父元素

						- 通过`position: relative;`设置成子元素的包含框

					- 子元素

						- 设置相对定位
						- 设置top/left偏移50%
						- top/left相对于框的左上角，通过设置margin为负值进行位移

- 动画

	- 过渡 transition

		- 将变化按照设置规则缓慢执行
		- 属性

			- 设置过渡动画的属性： transition-property
			- 设置过渡执行时间：transition-duration
			- 设置过渡动画延时执行时间：transition-delay
			- 设置过渡执行方式：transition-timing-function

				- 匀速： linear
				- 加速：ease-in
				- 减速： ease-out

		- 限制

			- 需要事件触发，因此没法在页面加载时自动执行
			- 一次性的没法多次执行
			- 只能定义开始和结束状态，不能定义中间状态
			- 一个transition只能设置一个属性

	- 动画 animation

		- 定义关键帧： @keyframes

		  ```
		  @keyframes scale_animation {
		      0% {
		          transform: scale(0.5);
		          background-color: green;
		      }
		      100% {
		          background-color: yellow;
		          transform: scale(1.5);
		      }
		  }
		  ```
		  
- 元素不显示

	- opacity: 0

		- 页面布局不会改变
		- 绑定事件会执行

	- visibility: hidden

		- 页面布局不会改变
		- 绑定事件不会触发

	- display:none

		- 页面布局被改变

	- position:absolute;top:-999em

		- 距离可视区范围太大无法显示

### js

- 数据类型

	- 基本类型

		- null

			- 不存在的属性，访问会抛出异常

		- undefined

			- 作用域中已经声明但未赋值的变量

		- string
		- number
		- boolean
		- symbol

	- 引用类型

		- Function
		- Array
		- Date

	- 判断类型

		- 通过`typeof`可以判断出：`string`、`number`、`boolean`、`undefined`及`function`
		- 使用`instanceof`可以判断一个实例是否是这个构造函数的实例
		- 使用`Object.prototype.toString.call(xxx)`判断引用类型

- 类型转换
- this

	- 默认绑定

		- 指向全局对象，浏览器window

	- 隐式绑定

		- 谁调用指向谁

	- 显示绑定

		- call、apply、bind

	- 箭头函数

		- 指向取决于定义
		- 限制

			- 不能作为构造函数，即不可以使用new关键字
			- 不可使用arguments对象
			- 不可以作为 Generator 函数

	- new

	  ```
	  function create(Con, ...args) {
	      let obj = {};
	      obj.__proto__ = Con.prototype;
	      let newObj = Con.apply(obj, args);
	      return newObj instanseof Object ? newObject : obj;
	  }
	  ```
	  
		- 指向创建的对象

- 作用域、作用域链

	- 作用域

		- 变量和函数的一套定义和查找规则，可以分为`块级作用域`和`函数作用域`。

	- 作用域链

		- 作用域嵌套，由`[[scope]]`属性和`AO`两部分组成
		- `[[scope]]`指向父变量对象和作用域。

- 闭包

	- 函数对象都会存在一个函数作用域，函数中的变量都会保存在这个作用域中，函数对象可以通过作用域链关联起来。
	- 执行上下文

		- 当页面首次加载JS时会创建一个`全局的执行上下文`，并加入到执行栈中，如果在执行的过程中遇到函数调用则会创建一个新的`执行上下文`，并将其加入到执行栈中。
		- 每个执行上下文包含一个`词法环境`和`变量环境`

			- 词法环境

			  ```
			  GlobalExectionContext = {
			      LexicalEnvironment: {
			          EnvironmentRecord: {
			          Type: "Object",
			          // 在这里绑定标识符
			          }
			          outer: <null>
			      }
			  }
			  
			  FunctionExectionContext = {
			      LexicalEnvironment: {
			          EnvironmentRecord: {
			          Type: "Declarative",
			          // 在这里绑定标识符
			          }
			          outer: <Global or outer function environment reference>
			      }
			  }
			  ``` 
			  
				- 环境记录

					- 存储变量和函数声明的实际位置

				- 外部环境的引用

					- 可以访问其他词法环境

			- 变量环境

				- 也是一个词法环境
				- ES6中词法环境用于存储`let`与`const`声明的变量、变量环境用于存储`var`声明的变量

		- 类型

			- 全局执行上下文
			- 函数执行上下文
			- eval执行上下文

- 原型、原型链

	- 原型

		- 原型`prototype`是一个对象，用于实现对象属性的继承。在Chrome和Firefox中，每个JS对象都存在一个`__proto__`属性指向构造函数的原型

	- 原型链

		- 每个对象都有一个`__proto__`属性，指向构造函数的原型，对象与对象之间可以通过`__proto__`属性进行连接即构成原型链。
		- 查找机制

			- 查找时如果自身不存在属性，则沿着原型链往上一级级的找，找到则输出，如果到了`Object.prototype`还未找到则返回`undefined`。

		- 修改机制

			- 只会修改本身的属性，如果不存在则会在当前作用域中添加属性

- 继承

	- 不使用`Object.create`

		- 原型链继承

			- 思想

				- 子类的原型指向父类实例

			- 优点

				- 父类的方法可以复用

			- 缺点

				- 父类的引用属性会被共享
				- 构建子类实例时不能传参给父类

		- 构造函数继承

		  ```
		  function Father () {}
		  function Son() {
		      // this 是通过new Son() 创建的对象
		      Father.call(this);
		  }
		  ```
		  
			- 思想

				- 子类的原型指向父类实例

			- 优点

				- 父类的引用属性不会被共享
				- 构建子类实例时可以传参给父类

			- 缺点

				- 父类的方法不可以复用

		- 组合继承

		  ```
		  function Father (name) {
		      this.name = name;
		  }
		  // 方法定义在原型对象上（共享）
		  Father.prototype.sayName = function(){
		      alert(this.name);
		  };
		  function Son(name) {
		      // this 是通过new Son() 创建的对象
		      Father.call(this, name);
		  }
		  Son.prototype = new Father();
		  ```
		  
			- 思想

				- 普通属性使用构造函数继承，函数使用原型链继承

	- 使用`Object.create`

		- 原型式继承

		  ```
		  function object(o){
		      function F(){}
		      F.prototype = o;
		      return new F();
		  }
		  ```
		  
			- 思想

				- 对参数的一个浅复制

			- 优点

				- 父类方法可以被复用

			- 缺点

				- 父类的引用属性会被共享
				- 构建子类实例时不能传参给父类

		- 寄生式继承

		  ```
		  function createAnother(original){ 
		      var clone=object(original);    //通过调用函数创建一个新对象
		      clone.sayHi = function(){      //以某种方式来增强这个对象
		          alert("hi");
		      };
		      return clone;                  //返回这个对象
		  }
		  ```
		  
			- 思想

				- 使用原型式继承获取目标对象的一个浅复制，然后增强这个浅复制的能力

		- 寄生组合继承

		  ```
		    function object(o) {
		      function F() {}
		      F.prototype = o;
		      return new F();
		    }
		  
		    function inheritPrototype(subType, superType){
		      var prototype = object(superType.prototype); // 创建了父类原型的浅复制
		      prototype.constructor = subType; // 修正原型的构造函数
		      subType.prototype = prototype; // 将子类的原型替换为这个原型
		    }
		    function SuperType(name){
		      this.name = name;
		      this.colors = ["red", "blue", "green"];
		    }
		    SuperType.prototype.sayName = function(){
		      alert(this.name);
		    };
		    function SubType(name, age){
		      SuperType.call(this, name);
		      this.age = age;
		    }
		    // 核心：因为是对父类原型的复制，所以不包含父类的构造函数，也就不会调用两次父类的构造函数造成浪费
		    inheritPrototype(SubType, SuperType);
		    SubType.prototype.sayAge = function(){
		      alert(this.age);
		    }
		    ```
		  
	- ES6 Class Extends

		- 本质上ES6继承是ES5继承的语法糖
		- ES5与ES6的不同

			- ES5

				- 先创建子类this，然后再对其增强

			- ES6

				- 先将父类的属性和方法加入this中、再用子类的构造函数修改这个this指向

- 事件循环

	- 宏任务
	- 微任务

- 异步

	- promise

		- Promise主要是用于解决回调地狱和回调不可信任问题的
		- Promise的状态变迁

			- pending -> fullfilled
			- pending -> rejected

		- 特点

			- Promise存在三种状态：pending（进行中）、fullfilled（完成）、rejected（拒绝）
			- Promise的状态改变后不能在发生改变
			- Promise的构造函数是一个同步任务，构造函数可以传入两个回调方法

		- 缺点

			- promise一旦执行就无法取消
			- 如果Promise内部抛出异常，且没有设置错误回调则异常会被吞掉
			- 外部无法用try catch进行异常捕获
			- 状态处于pending状态时无法区别时刚刚开始还是即将结束

		- API

			- all

				- 如果参数中存在不是Promise的实例，会先用Promise.resolve方法进行包装
				- 只有参数中的状态都变成fulfilled，状态才是fullfilled，返回的是一个数组
				- 只要参数中存在一个rejected，状态就是rejected，返回的是第一个reject的实例的返回值

			- race

			  一个请求超时的例子 - 如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数
			  ```
			  const p = Promise.race([
			    fetch('/resource-that-may-take-a-while'),
			    new Promise(function (resolve, reject) {
			      setTimeout(() => reject(new Error('request timeout')), 5000)
			    })
			  ]);
			  
			  p
			  .then(console.log)
			  .catch(console.error);
			  ```
			  
				- 只要参数中有一个状态发生改变则，状态就跟着改变
				- race也会先对参数进行处理，将其通过resolve进行包装

			- allSettled

				- 只有当所有参数都返回了包装实例才结束，一旦结束，状态总是fullfilled，不会变成rejected。

			- any

				- 参数中只要有一个实例的状态变成fullfilled，则包装实例就会变成fullfilled，如果所有状态变成 rejected 则实例就是 rejected。
				- any抛出的错误是一个 AggregateError 类型的错误

				  ```
				  {
				      errors: [rejected1, rejected2],
				      message: "All promises were rejected",
				      stack: "AggregateError: All promises were rejected"
				  }
				  ```
				  
			- resolve

				- 将一个对象转换成Promise对象。
				- 参数是一个 promise 实例，则不进行转换，直接返回 promise 实例
				- 参数是一个 thenable 实例（具有 then 方法的对象），resolve 方法会先将 thenable 对象转换成 Promise 对象，然后立即执行 thenable的 then 方法。
				- 参数不是类 thenable 对象，或根本就是不对象，返回一个新的Promise对象，状态变成 resolved
				- 不带参数，直接返回resolved状态的promise。注意：then的执行时机，then 属于微任务

			- reject

	- generator

	  ```
	  function* gen(x){
	        var y = yield x + 2;
	        return y;
	  }
	  ```
	  
		- 状态机，内部封装了多个状态
		- 最大特点是可以暂停执行，交出函数执行权
		- 调用 Generator 函数会返回一个迭代器对象，且不会执行函数内部逻辑，需要通过调用迭代器对象的`next()`方法
		- `next()`方法返回的是一个对象`{value: xxx: done: false}`
		- 判断是否为Generator函数

			```
			function isGenerator(fn){
				// 生成器示例必带@@toStringTag属性
				if(Symbol && Symbol.toStringTag) {
					return fn[Symbol.toStringTag] === 'GeneratorFunction';
				}
			}
			```
		  
			- fn[Symbol.toStringTag] === 'GeneratorFunction'

		- 数据交换

			- 通过调用`next()`的调用，函数向外输出数据
			- 通过向`next(xxx)`传入参数，向函数内部传入数据，参数`xxx`将作为yield的结果

	- async await

		- promise和generator的语法糖

		  ```
		  function spawn(genF) {
		      return new Promise(function(resolve, reject) {
		          // 返回一个迭代器对象
		          const gen = genF();
		          function step(nextF) {
		              let next;
		              try {
		                  next = nextF();
		              } catch(e) {
		                  return reject(e);
		              }
		  
		              if(next.done) {
		                  return resolve(next.value);
		              }
		              // 保证是一个promise对象
		              Promise.resolve(next.value).then(function(v) {
		                  step(function() { return gen.next(v); });
		              }, function(e) {
		                  step(function() { return gen.throw(e); });
		              });
		          }
		          step(function() { return gen.next(undefined); });
		      });
		  }
		  ```
		  
			- 将 Generator 函数和自动执行器，包装在一个函数里

		- async 做一件什么事情？

			- 对async函数的返回值进一步包装，确保返回的值是一个Promise对象

		- await 在等什么？

			- 等右侧的表达式结果

				- 如果右侧是一个函数，则函数的返回值就是等待的结果
				- 如果右侧是一个普通值，则这个普通值即是等待的结果

		- await 等到之后，做了一件什么事情？

			- await等待结果值后，会暂停执行async函数后面的代码，执行async后面的同步代码，最后执行async后面的代码

				- 如果await等到的结果是一个promise，则需要等待promise状态变成fullfilled，然后把resolve的参数作为await的等待值
				- 如果结果不是一个promise，即相当于`return Promise.resolve(xxx)`，会把xxx当做await的结果

- 事件流

	- 捕获
	- 冒泡
	- 事件委托

		- 使用JS的冒泡机制将子元素的事件委托给父元素

			- 大量减少内存占用，减少事件注册。
			- 新增元素实现动态绑定事件

- 模块

	- CommonJS

		- 输出值拷贝

			- 一旦输出一个值，模块内部变化不会影响这个值

		- 运行时加载

			- 加载的是一个对象（module.exports属性），该对象只在脚本运行时生成

		- 同步加载
		- 加载ES6模块

		  ```
		  (async () => {
		      await import('./my-app.mjs');
		  })();
		  ```
		  
			- 只能使用import()命令
			- CommonJS是同步的，ES6内部可以使用顶层await命令

		- 循环加载的处理

			- 遇到循环加载时只输出当前已经执行的部分

		- 加载原理

			- require第一次加载模块时，会执行整个脚本
			- 然后在内存中生成一个对象，属性包括ID、exports、loaded等

			  ```
			  {
			      id: '...',
			      exports: { ... },
			      loaded: true,
			      ...
			  }
			  ```
			  
			- 如果后面使用了该模块，则直接从exports中取
			- 如果再次执行require加载同一模块，会直接从内存中取

	- ES6

		- 输出值引用

			- JS引擎对脚本进行静态分析的时候，遇到import命令，会生成一个只读引用，在脚本运行时在根据这个引用去对应模块取值

		- 编译时输出接口

			- 模块不是对象，对外接口只是一种静态定义，在代码解析阶段就会生成

		- import() 是异步加载，有一个独立的模块依赖解析过程
		- import from 同步加载
		- 加载CommonJS模块

		  ```
		  // 正确
		  import packageMain from 'commonjs-package';
		  // 报错
		  import { method } from 'commonjs-package';
		  ```
		  
			- 可以使用import加载整体模块
			- ES6需要做静态分析，CommonJS输出的是一个对象，无法被静态分析

		- 循环加载的处理

			- JS执行后发现依赖了其他模块，则停止加载转而加载其他模块

### ts

## 浏览器

### 渲染过程

- 执行beforeUnload事件，卸载当前页面
- URL 解析

	- 如果是文本，则拼接成默认搜索引擎加关键字的 URL 进行搜索
	- 如果是 URL 就进行页面访问请求，并加上协议头（http、https 的区别）
	- encodeURI 与 encodeURIComponent

		- encodeURI

			- 可以对中文空格等编码，适用于整个URL

		- encodeURIComponent

			- 范围更广，会编码一些特殊字符，如:/?=+@#$，适用于给参数进行编码

- 判断是否存在缓存

	- 强缓存（200 from cache）与协商缓存（304）

- DNS解析

	- 流量器缓存中查找
	- 操作系统中查找
	- host文件中查找
	- 路由器缓存中找
	- 服务提供商中找
	- 到 DNS 服务器中查找，先根服务器，再顶级服务器

- 建立连接

	- HTTP连接
	- HTTPS连接

		- 客户端发请求（ClientHello）
		- 服务端回应（ServerHello）
		- 客户端回应
		- 服务端最后的回应

- 传输数据

	- 301/302
	- 根据 Content-Type 来判断响应文件类型

		- stream 类，浏览器启动下载界面下载文件。
		- text、图片类，浏览器直接展示在页面上
		- html 类型，浏览器会将响应交个渲染进程进行页面解析

- 断开连接

	- HTTP
	- HTTPS

- 结果渲染

	- Blink（排版） 渲染引擎

		- DOM解析

			- 生成DOM树

		- CSS计算

			- 收集、划分、索引所有样式表中的规则
			- 访问每个DOM元素并找到应用在该元素的所有规则
			- 结合这些规则及其其他信息生成最终的计算样式

		- 布局 - layout

			- 主线程遍历DOM结构和CSS规则，计算坐标和尺寸生成布局树
			- 为特定的 ReaderLayer 创建 GraphicsLayer

		- 合成更新

			- 思想

				- 把每个页面按照一定的规则分成多个图层，在渲染的时候只需要操作必要的图层，其他图层只需要参与合成就行

			- 什么样的 ReaderLayer 会被绘制成 GraphicsLayer

				- 具有 3D 或 transform 的CSS属性
				- filters

		- prepaint

			- 为了减低时间复杂度，构建属性树
			- 合成器提供变换树、裁剪树、特效树等，每个图层都有若干个节点ID，分别对应不同属性树

		- 绘制（paint）

			- 主线程遍历布局树并创建绘制记录

	- Layer Compositor

		- commit

			- 把主线程中 Paint 节点的数据（ layers、properties ）拷贝到合成器线程

		- Tiling

			- 分块渲染，把网页的缓存分为一格一格的小块
			- 合成器线程收到数据后，不会立即开始合成，而是进一步将图层使用分块渲染技术进行分块处理。
			- 分块渲染主要基于两个方面的考虑

				- 方便浏览器使用统一的缓冲池来管理缓存
				- GPU功能的限制 - 无法支持任意大小的缓存

		- Raster(栅格化)

			- 生成内存中像素的位图

		- Activate

			- 拷贝栅格化好的数据
			- Raster 和 Draw 都是发生在合成器线程里的布局树中，Raster 操作是异步的，加入 Activate 是为了解决 Draw 时 Raster 还未完成问题

		- Draw

			- 将栅格化的图块生成 draw quads

	- Display Compositor

		- Display

			- 输出像素点到屏幕

### 重绘（Repaint）和回流（Reflow）

- 概念

	- 重绘：元素样式改变且没有影响到元素在文档流中的位置时，浏览器将新样式付给元素并重新绘制。
	- 回流：元素的尺寸、结构、或某些属性发生改变

- 回流优化

	- CSS

		- 避免使用table布局
		- 避免使用CSS表达式
		- 尽可能的在DOM树的最末端改变class
		- 将动画应用在position属性为absolute或fixed中
		- 避免使用多层内联样式

	- JS

		- 避免频繁操作样式，将样式合并一起写或使用class属性
		- 避免频繁操作DOM，使用documentFragment操作DOM
		- 可以先通过设置display:none，等操作结束在将其设置回来

			- display值为none的属性进行操作不会引起回流和重绘

		- 避免频繁的读取会引起回流的属性，应将其暂存
		- 对于动画元素使用绝对定位使其脱离文档流

- 触发回流的操作

	- 页面初次渲染
	- 调整浏览器窗口大小
	- 元素尺寸、位置、内容发生改变，如padding
	- 元素字体发生改变
	- 添加或删除了可见的DOM元素
	- 激活CSS伪类
	- 查询某些属性或调用某些方法

		- client[Width、Height、Top、Left]
		- offset[Width、Height、Top、Left]
		- scroll[Width、Height、Top、Left]
		- getComputedStyle()
		- getBoundingClientRect()
		- scrollTo()

### 缓存

- 缓存类型

	- Service Worker

		- 使用过程

			- 注册
			- 监听 install 事件，缓存文件
			- 监听 activate 事件，旧的缓存文件的清除
			- 监听 fetch 事件，拦截请求

		- 生命周期

			- installing（安装中）

				- 注册之后，触发install回调，对一些静态资源进行缓存

			- installed（安装后）

				- ServiceWorker成功安装后便进入installed状态。至此Service完成了安装过程，等待进入激活过程。

			- activating（激活中）

				- ServiceWoker安装成功后进入activating状态。

			- activated（激活后）

				- ServiceWorker可以控制页面了，可以监听功能事件了，如fetch, push事件。

			- redundant（废弃）

				- register失败

	- Memory Cache

		- 保存在内存中的缓存，tab 页关闭了就释放

	- Disk Cache

		- 保存在磁盘中

	- Push Cache

		- HTTP/2 提供的缓存，session 关闭缓存就释放

- 缓存策略

	- 强缓存

		- 浏览器判断本地缓存未失效，直接取本地数据，不发起HTTP请求，http返回状态码是200（from memory cache或者from disk cache）
		- 请求头

			- Pragam/Expires（1.0）

				- Expires 响应头包含日期/时间， 即在此时候之后，响应过期。

			- Cache-Control（1.1）

				- max-age： 缓存资源，在指定秒数后过期
				- no-cache：相当于max-age: 0
				- no-store：请求和响应都不缓存

	- 协商缓存

		- 浏览器发送请求给服务端，服务端返回304，提示缓存未失效
		- 请求头

			- If-Modified-Since/Last-Modified（1.0）

				- 过程

					- 客户端第一次访问时，服务端会在响应头中加入 Last-Modified 响应头，标识这个文件在服务器端最后被修改的时间。
					- 当客户端再次访问是，会在请求头中携带一个 If-Modified-Since，用来向服务器询问该时间后文件是否被改过。

				- 缺点

					- 只能精确到秒级别
					- 无法识别文件内容是否发生变化

			- If-No-Match/Etag（1.1）

				- 过程

					- 浏览器第一次访问时，服务端返回状态码200，同时在响应头中增加Etag，存放着服务器端生成的一个序列值；
					- 浏览器第二次访问时，会在请求头中增加If-None-Match，值是第一次返回的Etag值，服务器通过比较其值判断是否过期。

				- Nginx ETag计算方式

					- 计算页面文件的最后修改时间，将文件最后修改时间的秒级Unix时间戳转为16进制作为etag的第一部分
					-  计算页面文件的大小，将大小字节数转为16进制作为etag的第二部分。

				- ETag有两种类型

					- 强ETag

						- 不论实体发生多么细微的变化都会改变其值 - "22FAA065-2664-4197-9C5E-C92EA03D0A16"

					- 弱ETag

						- 资源发生了根本改变产 生差异时才会改变 ETag  - W/"22FAA065-2664-4197-9C5E-C92EA03D0A16"

### 跨域

- 协议、域名、端口只要有一个不同即是跨域。
- 导致跨域的方式

	- DOM同源策略

		- 禁止对不同源的DOM进行操作，不同源的iframe限制互相访问。

	- XMLHttpRequest同源策略

		- 禁止使用XHR对不同源的服务器发起请求

- 为何要有跨域限制

	- 保证用户信息的安全，防止恶意的网站窃取数据

		- AJAX同源策略用来防止CSRF攻击，如果没有AJAX同源限制，则每次发起请求都会携带源地址的cookie

-  同源限制范围

	- Cookie、LocalStorage、IndexDB无法读取
	- DOM无法获取
	- AJAX请求不能发送

- 没有限制的标签

	- <img>的src（获取图片）
	- <link>的href（获取css）
	- <script>的src（获取javascript）
	- iframes 允许跨域嵌入，取决于X-Frame-Options HTTP头的设置，但不允许跨域读取
	- forms 允许将数据写入跨域服务器

- cookie

	- document.domain

		- 如果两个网址，一级域名相同，只是二级域名不同，通过设置document.domain来共享cookie和读取iframe的DOM
		- 这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexDB 无法通过这种方法，规避同源政策，而要使用下文介绍的PostMessage API
		- 服务器也可以在设置Cookie的时候，指定Cookie的所属域名为一级域名，比如.example.com。

		  Set-Cookie: key=value; domain=.example.com; path=/
		  
- IFRAME

	- 片段标识符

		- 片段标识符（fragment identifier）指的是，URL的#号后面的部分
		- 父窗口可以把信息，写入子窗口的片段标识符。

		  var src = originURL + '#' + data;
		  document.getElementById('myIFrame').src = src;
		  
		- 子窗口通过监听 hashchange 事件得到通知。

		  window.onhashchange = checkMessage;
		  
		  function checkMessage() {
		    var message = window.location.hash;
		    // ...
		  }
		  
	- window.name

		- 浏览器窗口有window.name属性。这个属性的最大特点是，无论是否同源，只要在同一个窗口里，前一个网页设置了这个属性，后一个网页可以读取它。
		- 父窗口先打开一个子窗口，载入一个不同源的网页，该网页将信息写入window.name属性。

		  window.name = data;
		  
		- 接着，子窗口跳回一个与主窗口同域的网址。

		  location = 'http://parent.url.com/xxx.html';
		  
		- 然后，主窗口就可以读取子窗口的window.name了。

		  var data = document.getElementById('myFrame').contentWindow.name;
		  
		- 优点

			-  window.name容量很大，可以放置非常长的字符串；

		- 缺点:

			- 必须监听子窗口window.name属性的变化，影响网页性能。

	- 跨文档通信API（Cross-document messaging）

		- 新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。
		- 父窗口http://aaa.com向子窗口http://bbb.com发消息

		  var popup = window.open('http://bbb.com', 'title');
		  popup.postMessage('Hello World!', 'http://bbb.com');
		  
		- 子窗口向父窗口发送消息

		  window.opener.postMessage('Nice to see you', 'http://aaa.com');
		  
		- 父窗口和子窗口都可以通过message事件，监听对方的消息。

		  window.addEventListener('message', function(e) {
		    console.log(e.data);
		  },false);
		  
		- API

			- message事件的事件对象event，提供以下三个属性

				- event.source：发送消息的窗口
				- event.origin: 消息发向的网址
				- event.data: 消息内容

			- 可以通过event.source给发送者回复信息

			  window.addEventListener('message', receiveMessage);
			  function receiveMessage(event) {
			    event.source.postMessage('Nice to see you!', '*');
			  }
			  
- AJAX

	- WebSocket

		- WebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。
		- 浏览器发出的WebSocket请求的头信息

		  GET /chat HTTP/1.1
		  Host: server.example.com
		  Upgrade: websocket
		  Connection: Upgrade
		  Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
		  Sec-WebSocket-Protocol: chat, superchat
		  Sec-WebSocket-Version: 13
		  Origin: http://example.com
		  
		- 因为有了Origin这个字段，所以WebSocket才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。

		  HTTP/1.1 101 Switching Protocols
		  Upgrade: websocket
		  Connection: Upgrade
		  Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
		  Sec-WebSocket-Protocol: chat
		  
	- JSONP

		- 原理

			- web前端事先定义一个获取跨域响应数据的回调。
			- 然后通过没有同源限制的script标签发起请求，将第1步中定义的回调函数设置在script中的src属性的query参数中
			- 服务端返回这个回调函数的执行，并将需要返回的数据放到回调函数的参数中
			- 前端的script标签请求到这个执行的回调函数后会立即执行，这样就可以拿到返回的数据了

		- 缺点

			- JSONP只能发GET请求

		- jsonp的安全性

			- CSRF攻击
			- XSS漏洞

	- CORS

		- 简单请求

			- 什么是简单请求

				- HEAD、GET、POST三种方法中的其中一种
				- Http的请求头只能包括

					- Accept
					- Accept-Language
					- Content-Language
					- Last-Event-ID
					- Content-Type(application/x-www-form-urlencoded、multipart/form-data、text/plain)

			- 基本流程

				- 浏览器在请求头中增加一个Origin属性，表明本次请求来源那个源（协议+域名+端口）
				- 服务器收到请求后根据这个值决定请求返回

					- 不允许跨域，则返回一个不带Access-Control-Allow-Origin请求头的成功响应
					- 指定许可范围内，服务器返回成功响应，同时在响应头中带上一些请求头

				- 浏览器根据上面返回的请求头中是否包含Access-Control-Allow-Origin判断是否成功

			- 相关头信息

				- Access-Control-Allow-Origin: *
				- Access-Control-Allow-Credentials: true

					- 表示浏览器是否可以发送cookie给服务器，默认情况下，Cookie不包括在CORS请求之中

				- Access-Control-Expose-Headers: Foo

					- 指定请求时XMLHTTPRequest对象的 getResponseHeader() 方法能拿到请求头

				- Content-type: text/html

		- 非简单请求

			- 对服务器有特殊要求的请求，如方法是PUT或DELETE，或者Content-Type是applcation/json
			- 基本流程

				- “预检”请求。

					- 浏览器发现CORS请求是一个非简单请求，浏览器会自动发送一个OPTIONS请求

				- 服务器对预检确认

					- 预检失败

						- 服务器返回一个不包含任何CORS相关头信息的成功请求

					- 预检成功

						- 允许跨源请求，附带一些响应头

				- 浏览器收到服务器对预检请求的确认

					- 不允许跨源请求，会触发一个错误，被 XMLHttpRequest 的onerror捕获
					- 如果通过了预检则可以正常发送请求

			- 相关头信息

				- 客户端

					- Access-Control-Request-Method

						- 列出请求用到的方法

					- Access-Control-Request-Headers

						- 一个逗号分隔的字符串，表示请求会用到请求头

				- 服务端

					- Access-Control-Allow-Methods

						- 逗号分隔的字符串，表明服务器支持的所有跨源请求，避免多次发送预检请求。

					- Access-Control-Allow-Headers

						- 逗号分隔的字符串，表明服务器支持的请求头字段

					- Access-Control-Max-Age

						- 指定本次预检的有效期，在此区间不需要发送其他预检请求

### 安全

- xss

	- XSS 注入的方法

		- 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。

		  ```
		  <input type="text" value="<%= getParameter("keyword") %>">
		  <button>搜索</button>
		  <div>
		    您搜索的关键词是：<%= getParameter("keyword") %>
		  </div>
		  ```
		  
			- 当浏览器请求 http://xxx/search?keyword="><script>alert('XSS');</script> 时
			- 服务端会解析出请求参数 keyword，得到 "><script>alert('XSS');</script>
			- 拼接到 HTML 中返回给浏览器。

		- 在内联的 JS 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。

		  ```
		  <script>
		  var initData = <%= data.toJSON() %>
		  </script>
		  ```
		  
			- 当 JSON 中包含字符串 </script> 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析
			- 通过增加下一个 <script> 标签等方法就可以完成注入

		- 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
		- 在标签的 href、src 等属性中，包含 javascript: 等可执行代码

		  ```
		  <a href="<%= escapeHTML(getParameter("redirect_to")) %>">跳转...</a>
		  ```
		  
			- 攻击者构造 URL http://xxx/?redirect_to=javascript:alert('XSS')，服务端响应后，一旦用户点击 a 标签时，浏览器会完成攻击。

		- 在 onload、onerror、onclick 等事件中，注入不受控制代码。

	- 本质

		- 恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

	- XSS 攻击的分类

		- 存储型

			- 攻击者将恶意代码提交到数据库，客户端查询时拼接在HTML中返回，然后浏览器执行

		- 反射型

			- 攻击者构造恶意URL，用户打开URL后，发送请求到服务器，服务器取出内容，拼接恶意代码到HTML中返回给浏览器，浏览器执行混合恶意代码的内容

		- DOM 型

			- 攻击者构造恶意URL，用户点击后发送请求，返回后将恶意代码取出执行

	- 预防

		- 预防存储型和反射型 XSS 攻击

			- 纯前端渲染，把代码和数据分隔开

				- 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据
				- JS 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上

			- 对 HTML 做充分转义

				- 使用DOMPurify依赖库
				- 使用trustedTypes.createPolicy创建自定义过滤策略

		- 预防 DOM 型 XSS 攻击

			- 确保数据来源可靠
			- .innerHTML、.outerHTML、document.write()，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等
			- eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行

- csrf

	- 攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
	- CSRF攻击流程

		- 用户登录网址：bank.example，并保留了登录信息
		- 用户点击了攻击者提供的诱导链接，访问了benk.example
		- benk.example向bank.example发送了一个请求：withdraw?account=xm&amount=1&for=hacker。该请求会附带 bank.example 中的 cookie。
		- bank.example 接收到请求后，对请求进行验证发现携带了用户的登录信息
		- 验证成功，以攻击者的名义执行了代码

	- 类型

		- GET类型的CSRF

			- 受害者访问包含攻击者提供的页面后，浏览器会自动向http://bank.example/withdraw?account=xm&amount=1&for=hacker发出一次HTTP请求

		- POST类型的CSRF

			```
			<form action="http://bank.example/withdraw" method=POST>
				<input type="hidden" name="account" value="xiaoming" />
				<input type="hidden" name="amount" value="10000" />
				<input type="hidden" name="for" value="hacker" />
			</form>
			<script> document.forms[0].submit(); </script> 
			```
		  
			- 通常使用的是一个自动提交的表单
			- 访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

		- 链接类型的CSRF

	- CSRF的特点

		- CSRF（通常）发生在第三方域名
		- 攻击者利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据
		- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”
		- 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等

	- 预防

		- 阻止不明外域的访问

			- 同源检测

				- 异步请求会携带origin和referer头信息，用于表示信息来源域名，且不能进行修改，由浏览器自动附带。
				- Origin在以下两种情况下并不存在

					- IE11同源策略

						- IE 11 不会在跨站CORS请求上添加Origin标头，Referer头将仍然是唯一的标识

					- 302重定向

						- 在302重定向之后Origin不包含在重定向的请求中，因为Origin可能会被认为是其他来源的敏感信息。

		- 提交时要求附加本域才能获取的信息

			- Token

				- 所有的用户请求都携带一个CSRF攻击者无法获取到的Token。服务器通过校验请求是否携带正确的Token，来把正常的请求和攻击的请求区分开，也可以防范CSRF的攻击
				- 原理

					- 将CSRF Token输出到页面中

						- 打开页面时向后台请求一个token，该token包括随机值和时间戳并经过加密算法加密，同时将该token存储在session中，页面将该token值加入到DOM树中的a标签和from标签中。

					- 页面提交的请求携带这个Token

						- 对于get请求，在URL后面加上这个token

							- http://url?csrftoken=tokenvalue

						- 对于post请求，要在form中加入一个隐藏的input域

							- <input type=”hidden” name=”csrftoken” value=”tokenvalue”/>

					- 服务器验证Token是否正确

						- 服务器取出请求的token值加密与session中的值做比较

			- 双重Cookie验证

				- 用户访问页面，向请求域名中注入一个cookie，内容为随机字符串
				- 前端向后端发送接口时，取出cookie，并添加到请求URL参数中
				- 后端校验请求URL参数和cookie中的值是否一致

		- Samesite Cookie

			- 为Set-Cookie响应头新增Samesite属性，它用来标明这个 Cookie是个`同站 Cookie`，同站Cookie只能作为第一方Cookie，不能作为第三方Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax
			- Set-Cookie: foo=1; Samesite=Strict Set-Cookie: bar=2; Samesite=Lax Set-Cookie: baz=3

				- foo严格模式

					- 表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie
					- 在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会

				- bar宽松模式

					- 这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个GET请求

						- 这个Cookie可以作为第三方Cookie

					- 当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会

						- 在不同网站之间通过链接跳转Cookie不受影响

					- 从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则bar也不会发送

- 内容安全策略（CSP）

### 进程

- Browser进程

	- 控制界面显示，界面交互；
	- 负责页面管理，创建和销毁其他进程；
	- 将渲染进程得到的结果，绘制在界面中；

- GPU进程

	- 3D绘制

- 渲染进程

	- 页面渲染、脚本执行等
	- 线程

		- 主线程
		- JS引擎线程
		- 事件触发线程
		- 定时触发线程
		- 异步http请求线程
		- 合成线程
		- 光栅线程

- 第三方插件进程

### 浏览器引擎

- webkit
- blink
- gecko

### 架构

- Blink（排版） 渲染引擎

	- 渲染进程中的主线程处理
	- 负责HTML、CSS的解析、JS的解释执行、DOM操作，排版、图层树的构建，更新等操作
	- 输出：Main Frame

		- 包含对网页内容的描述，主要以绘图指令的形式或是某一个时间点对整个网页的矢量图快照。

- Layer Compositor（图层合成器）

	- Render 进程中的 Compositor 线程
	- 负责接收 Blink 生成的 Main Frame，负责图层树的管理，图层的滚动、旋转等矩阵变化，光栅化，纹理上传等
	- 输出：Compositor Frame

		- Layer Compositor需要给每个图层进行分块，为每个分块分配Resource，然后安排光栅化任务
		- 给当前可见区域的每一个图层的每一个分块生成一个Draw Quad的绘制指令

- Display Compositor

	- Browser 进程中的 UI 线程
	- 负责接收 Layer Compositor 线程生成的 Compositor Frame，最终输出OpenGL指令，将内容通过GL贴图绘制到目标窗口上
	- 输出：GL/UI Frame

		- 将每一个Draw Quad绘制指令转换为一个GL多边形绘制指令，

### V8引擎

- V8 内存构成

	- 新生代内存区（new space）

		- 被分成两部分，每次只使用一部分内存

	- 老生代内存区（old space）
	- 大对象区（large object space）
	- 代码区（code space）

		- 代码对象，会被分配在这里。唯一拥有执行权限的内存；

	- map 区（map space）

		- 存放 Cell 和 Map，每个区域都是存放相同大小的元素，结构简单

- V8 内存生命周期

	- 对象被分配到了 new space
	- new space 塞满了，gc 开始清理 new space 里的死对象

		- 清理 new space 的过程叫做 Scavenge
		- 采用了空间换时间的做法，将new space分成两个区域，每次只使用一个区域，被当做inactive  new space
		- 过程

			- 当活越区域空间满了以后，交换活跃区域与非活跃区域，交换或活跃区域为空
			- 将非活跃区域中两次都没清理掉的对象，移到old space区域
			- 将非活跃区域的中还存活的对象移动到活跃区域

	- gc 清理了两遍 new space后，会将存活的对象移到old space区
	- 程序运行过程中，如果没有被引用的对象，在发生old space区域的垃圾回收后将被清除掉

		- 清理 old space 的过程叫做 Mark-sweep 
		- Mark-sweep 就是把从根节点无法获取到的对象清理掉了
		- 过程

			- 标记从根（root）可达的对象为黑色；
			- 遍历黑色对象的邻接对象，直到所有对象都标记为黑色
			- 循环标记若干次
			- 清理掉非黑色的对象

## 网络

### http

- 分层

	- 应用层

		- 网络应用程序和网络协议存放的分层，包括HTTP、FTP、SMTP等协议

	- 运输层

		- 负责应用程序端点之间进行报文传送，包括TCP、UDP协议
		- TCP

			- 确保报文段能够准确的送到目的地
			- 提供拥塞机制来控制网络传送

		- UDP：不具备可靠性，且没有拥塞机制。

	- 网络层

		- 负责将数据报从一台主机传送到另一台主机上，包含IP、路由选择协议

	- 链路层
	- 物理层

		- 负责将帧数据从一个端系统运输到另一个端系统。

- 内容协商

	- 协商方式

		- 主动式内容协商

			- 客户端在请求头中提出需要的表述形式
			- 服务器根据客户端提供的表述形式提供内容

		- 响应式内容协商

			- 服务端返回300或406，由客户端自己选择需要展示的内容

	- 协商要素

		- 质量因子q
		- 媒体资源的MIME类型及质量因子
		- 内容编码：主要指压缩算法
		- 表述语言

- 状态码

	- 1xx

		- 请求已经接收到，需要进一步处理才能完成，HTTP/1.0 不支持
		- 100 Continue：上传大文件前使用
		- 101 Switch Protocols：协议升级使用

	- 2xx

		- 成功处理请求
		- 206 Partial Content：使用range协议时返回部分响应内容时的响应码

	- 3xx

		- 300：是一个特殊的重定向状态码，会返回一个有多个链接选项的页面，由用户自行选择
		- 301 永久性重定向
		- 302 临时性重定向
		- 303：类似于 302，重定向后的请求方法改为 GET 方法
		- 307：类似于 302，含义比 302 更明确，重定向后请求的方法和实体不允许变动
		- 308：类似于 301，代表永久重定向，重定向后请求的方法和实体不允许变动

	- 4xx

		- 客户端错误
		- 400

			- Bad Request（坏请求）

		- 401

			- Unauthorized（未授权）

		- 403
		- 404

	- 5xx

		- 服务器错误
		- 500 服务器异常
		- 502 网关错误
		- 503 服务不可用
		- 504 网关超时

- get、post的区别

	- get

		- get请求时，浏览器会把header和data数据合并一起发送出去，等待返回200状态码

	- post

		- post请求时，浏览器会先把header发送出去，等待服务器返回100
		- continue后浏览器再次发送data，等待返回200状态码

### https

- HTTP加上加密和认证及完整性后就是HTTPS
- 握手过程

	- 客户端发请求（ClientHello）

		- 请求参数包括

			- 支持的协议版本
			- 支持的加密算法
			- 压缩方法
			- 随机数

	- 服务端回应（ServerHello）

		- 服务确认

			- 加密通信使用的版本，不同会终止
			- 加密方法

		- 返回的数据

			- 服务端的证书
			- 服务端生成的随机数

	- 客户端回应

		- 首先验证证书是否可信，如果不可信，则给提示，由客户端自己决定是否继续
		- 如果可信则再次给服务端回应

			- 客户端处理

				- 取出证书中服务器的公钥
				- 编码变更通知
				- 客户端握手结束通知

			- 客户端发送数据

				- 重新生成一个随机数，使用公钥进行加密

	- 服务端最后的回应

		- 服务端处理

			- 取出客户端发送的随机数和之前的生成对称秘钥
			- 编码改变通知
			- 服务器握手结束通知

- 依赖算法

	- 非对称加密

		- 用途

			- 身份认证和秘钥协商

		- 存在公开密钥和私有密钥，服务器使用私有密钥进行加密解密
		- 缺点

			- 中间人篡改

				- 数字证书

			- 非对称加密解密比较耗时

				- 在交换密钥环节使用非对称加密，之后建立通信交换报文使用对称加密

	- 对称加密

		- 信息加密

			- 交换报文使用对称加密。

	- 散列算法

		- 完整性校验

			- 数字签名

- 解决HTTP存在的问题

	- 信息窃听

		- 加密

			- 对称加密

				- 加密和解密使用同一个钥匙

			- 非对称加密

				- 同时使用公钥和私钥

			- 对称+非对称

				- 交换秘钥阶段使用非对称加密，通信时使用对称加密

	- 信息篡改

		- 数字签名

			- 生成数字签名流程

				- 先用 HASH 函数生成消息摘要
				- 然后使用发送者的私钥加密生成数字签名，并与原文一起发送给接收者

			- 验证数字签名流程

				- 接收者使用公钥解密被加密的信息摘要
				- 然后用 hash 函数对接收到的原文生成一个消息摘要，并与上一步的进行比对

	- 信息劫持

		- 数字证书

			- 认证流程

				- 服务器把自己的公钥、组织信息及域名等数据提交给CA。
				- CA进行认证，然后用CA的私钥进行签名，生成数字签名，然后将证书返回给服务端，证书包括CA生成的数字签名及服务器的公钥 - 证书

					- 首先使用hash 函数生成明文信息摘要
					- 然后用自己的私钥对摘要进行加密

				- 客户端向服务端发送请求时，服务端返回证书文件。
				- 客户端获取到证书后，用相同 hash 函数生成摘要，然后用证书认证机构提供的公钥解密签名数据。

### http2

- 优点

	- 头部压缩

		- http2 采用 HPACK 算法进行头部压缩。
		- HPACK存在一个静态表
		- 同时还存在一个连接级的动态表
		- HPACK首部分为4个类型

			- 索引首部字段类型

				- 当首部名称和值都在表（包括静态表和动态表）中时。- 以1开始
				- 比如： 需要编码 :method: GET， 使用索引2，转换成2进制为 1000 0010，即82（16进制）

			- 带递增索引的字符串首部字段

				- 当首部值不在表中，要将其添加到动态表中以备后续使用时 - 以 01 开头。
				- 格式一：首部名已经在索引表中

				  ```
				  01 index(6+)
				  H value length(7+)
				    value string
				  ```
				  
					- H = 1，表示使用Huffman编码
					- H = 0，表示使用ASCII编码

				- 格式二：首部名不在索引表中

				  ```
				  01 000000
				  H  Name length(7+)
				    Name string
				  H  Value length(7+)
				    Value string
				  ```
				  
			- 不索引的字符串首部字段

				- 每个请求中会发生变化的请求，首部名和值不会加入动态表中。- 以0000开头
				- 格式一：首部名已经在索引表中
				- 格式二：首部名不在索引表中

			- 从不索引的字符串首部

				- 一定不能在任何后续的重新编码流程中被添加到动态表中。-以0001开头
				- 格式一：首部名已经在索引表中
				- 格式二：首部名不在索引表中

	- 服务器端推送

		- 服务端可以给一个请求返回多个响应。

	- 使用二进制传输

		- http1.1 采用文本格式
		- http2 采用二进制传输数据
		- http2 把数据分成HEADERS和DATA两个帧

	- 多路复用代替同步请求

		- http1.1 是同步的、独占的请求-响应协议。
		- http2 允许在单个连接上同时执行多个请求

			- 通过使用二进制分帧层，给每个帧分配一个流标识符

- 缺点

	- 依旧存在 TCP 阻塞

### http3

- 基于 QUIC 协议的 HTTP （HTTP over QUIC）

	- Quick UDP Internet Connections
	- 整合了 TCP、TLS 和 HTTP/2 的优点，并加以优化
	- QUIC 是用来替代 TCP、SSL/TLS 的传输层协议
	- 在 QUIC 之上的 HTTP 协议被称为 HTTP/3，这就是”HTTP over QUIC 即 HTTP/3“的含义

- DH 密钥交换算法
- QUIC 的连接过程

	- 首次连接时，客户端发送 Inchoate Client Hello 给服务端，用于请求连接
	- 服务端生成 g、p、a，根据 g、p 和 a 算出 A，然后将 g、p、A 放到 Server Config 中再发送 Rejection 消息给客户端
	- 客户端接收到 g、p、A 后，自己再生成 b，根据 g、p、b 算出 B，根据 A、p、b 算出初始密钥 K。B 和 K 算好后，客户端会用 K 加密 HTTP 数据，连同 B 一起发送给服务端；
	- 服务端接收到 B 后，根据 a、p、B 生成与客户端同样的密钥，再用这密钥解密收到的 HTTP 数据。为了进一步的安全（前向安全性），服务端会更新自己的随机数 a 和公钥，再生成新的密钥 S，然后把公钥通过 Server Hello 发送给客户端。连同 Server Hello 消息，还有 HTTP 返回数据；
	- 客户端收到 Server Hello 后，生成与服务端一致的新密钥 S，后面的传输都使用 S 加密。

- 连接迁移

	- TCP 连接基于四元组（源 IP、源端口、目的 IP、目的端口）
	- QUIC 的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持

		- 使用一个 64 位的Connection ID随机数，即使 IP 或者端口发生变化，只要 Connection ID 没有变化，那么连接依然可以维持

- 队头阻塞/多路复用

	- HTTP/1.1 和 HTTP/2 都存在队头阻塞问题（Head of line blocking）
	- 什么是队头阻塞？

		- HTTP/1.1

			- 一系列请求到达服务器后，如果中间有一个请求丢失了，则会阻塞后面请求的处理

		- HTTP/2

			-  HTTP/2 的基础 TCP 协议本身却也存在着队头阻塞的问题
			- 浏览器要求 HTTP/2 必须使用 HTTPS，而 HTTPS 使用的 TLS 协议也存在队头阻塞问题

				- TLS 基于 Record 组织数据，将一堆数据放在一起（即一个 Record）加密，加密完后又拆分成多个 TCP 包传输。
				- 一般每个 Record 16K，包含 12 个 TCP 包，这样如果 12 个 TCP 包中有任何一个包丢失，那么整个 Record 都无法解密

	- 队头阻塞会导致 HTTP/2 在更容易丢包的弱网络环境下比 HTTP/1.1 更慢！
	- QUIC 是如何解决队头阻塞问题？

		- QUIC 的传输单元是 Packet，加密单元也是 Packet，整个加密、传输、解密都基于 Packet，这样就能避免 TLS 的队头阻塞问题
		- QUIC 基于 UDP，UDP 的数据包在接收端没有处理顺序，即使中间丢失一个包，也不会阻塞整条连接，其他的资源会被正常处理

- 拥塞控制

	- TCP 的拥塞控制

		- 慢启动

			- 依次发送1,2,4,8...n单位的数据，n呈指数级增长，不断试探网络的拥塞程度

		- 拥塞避免

			- 当n到达某个限制（慢启动阈值）之后，指数增长变为线性增长

		- 快速重传

			- 发送方每一次发送时都会设置一个超时计时器，超时后即认为丢失，需要重发

		- 快速恢复

			- 重传也会启动一个超时定时器，收到确认消息则进入拥塞避免阶段，否则回到慢启动阶段

	- QUIC 改进的拥塞控制的特性

		- 热插拔

			- QUIC 修改拥塞控制策略只需要在应用层操作，并且 QUIC 会根据不同的网络环境、用户来动态选择拥塞控制算法

		- 前向纠错 FEC

			- QUIC 使用前向纠错(FEC，Forward Error Correction)技术增加协议的容错性
			- 将数据分成n个包，依次对每个包进行异或运算，运算结果会作为 FEC 包与数据包一起被传输，如果不幸在传输过程中有一个数据包丢失，那么就可以根据剩余 n - 1个包以及 FEC 包推算出丢失的那个包的数据

		- 单调递增的 Packet Number

			- TCP 

				- TCP 为了保证可靠性，使用 Sequence Number 和 ACK 来确认消息是否有序到达
				- 超时发生后客户端发起重传，后来接收到了 ACK 确认消息，客户端不能区别时前面的还是重试的ACK

			- QUIC

				- Packet Number 严格单调递增

		- ACK Delay

			- TCP 计算 RTT（Round Trip Time，往返时间） 时没有考虑接收方接收到数据到发送确认消息之间的延迟

		- 更多的 ACK 块

			- TCP SACK 最多提供 3 个 ACK block
			- QUIC 最多可以捎带 256 个 ACK block

- 流量控制

## 构建工具

### webpack

- 本质

	- webpack是一个基于事件流的编程范例

- 基础配置

	- entry

		- 单个入口

			- entry: string|Array<string>

		- 多个入口

			- entry: {[entryChunkName: string]: string|Array<string>}

	- output

		```
		{
			entry: {
				app: './src/app.js',
				search: './src/search.js'
			},
			output: {
				filename: '[name].js',
				path: __dirname + '/dist'
			}
		}
		```
	  
		- filename

			- 配置输出文件的文件名

		- 描述了如何处理归拢在一起的代码(bundled code)

	- loader

		- 两个目标

			- 识别出(identify)应该被对应的 loader 进行转换(transform)的那些文件。(test 属性)
			-         转换这些文件，从而使其能够被添加到依赖图中（并且最终添加到 bundle 中）(use 属性)

		- loader 用于对模块的源代码进行转换。
		- 使用 loader

			- 配置方式（推荐）：在 webpack.config.js 文件中指定 loader。

				- 通过module.rules配置
				- loader 从右到左（或从下到上）地取值(evaluate)/执行(execute)

			- 内联方式：在每个 import 语句中显式指定 loader。
			  ```
			  import
			    Styles 
			  from 
			    'style-loader!css-loader?modules!./styles.css';
			  ```
			  
				- 使用 ! 将资源中的 loader 分开
				- 通过为内联 import 语句添加前缀，可以覆盖 配置 中的所有 loader, preLoader 和 postLoader：

					- 通过为内联 import 语句添加前缀，可以覆盖 配置 中的所有 loader, preLoader 和 postLoader：
					- 使用 !! 前缀，将禁用所有已配置的 loader（preLoader, loader, postLoader）
					- 使用 -! 前缀，将禁用所有已配置的 preLoader 和 loader，但是不禁用 postLoaders

			- CLI 方式：在 shell 命令中指定它们。
			  ```
			  webpack --module-bind pug-loader --module-bind 'css=style-loader!css-loader'
			  ```
			  
	- plugins

		- 插件目的在于解决 loader 无法实现的其他事
		- webpack 插件是一个具有 apply 方法的 JavaScript 对象

- 编译原理

	- 初始化阶段

		- webpack控制

			- 1. 验证配置Schema
			- 2. 参数合并 - WebpackOptionsDefaulter
			  ```
			  options = new WebpackOptionsDefaulter().process(options);
			  ```
			- 3. 实例化Compiler
			  ```
			  compiler = new Compiler(options.context);
			  
			  
			  class Compiler extends Tapable {
			  	    constructor(context) {
			  		        super();
			  		        this.hooks = {
			              ......
			              make: new AsyncParallelHook(["compilation"]),
			              // 触发 compilation 事件之前执行
			  			            thisCompilation: new SyncHook(["compilation", "params"]), 
			              ......
			          }
			  ```
			- 4. 实例化自定义插件
			  ```
			  if (options.plugins && Array.isArray(options.plugins)) {
			      for (const plugin of options.plugins) {
			          if (typeof plugin === "function") {
			              plugin.call(compiler, compiler);
			          } else {
			              plugin.apply(compiler);
			          }
			      }
			  }
			  ```
			- 5. 初始化自定义和内置的插件逻辑 - WebpackOptionsApply
			  ```
			  compiler.options = new WebpackOptionsApply().process(options, compiler);
			  
			  
			  class WebpackOptionsApply extends OptionsApply {
			      process(options, compiler) {
			          // 添加 entryOption 钩子回调
			          new EntryOptionPlugin().apply(compiler);
			          // 触发entryOption回调
			           compiler.hooks.entryOption.call(options.context, options.entry);
			      }
			  }
			  ```
				- 主要内置插件

					- EntryOptionPlugin 
					  ```
					  const itemToPlugin = (context, item, name) => {
					      if (Array.isArray(item)) {
					          return new MultiEntryPlugin(context, item, name);
					      }
					      return new SingleEntryPlugin(context, item, name);
					  };
					  
					  module.exports = class EntryOptionPlugin {
					      apply(compiler) {
					          compiler.hooks.entryOption.tap("EntryOptionPlugin", (context, entry) => {
					              if (typeof entry === "string" || Array.isArray(entry)) {
					                  // 如果传入一个字符串或字符串数组，chunk 会被命名为 main
					                  itemToPlugin(context, entry, "main").apply(compiler);
					              } else if (typeof entry === "object") {
					                  // 每个键(key)会是 chunk 的名称，该值描述了 chunk 的入口起点
					                  for (const name of Object.keys(entry)) {
					                      itemToPlugin(context, entry[name], name).apply(compiler);
					                  }
					              } else if (typeof entry === "function") {
					                  // 如果entry提供的是一个函数，则使用 DynamicEntryPlugin 插件加载入口文件
					                  new DynamicEntryPlugin(context, entry).apply(compiler);
					              }
					              return true;
					          });
					      }
					  };
					  ```
						- 根据不同的entry配置，初始化不同实例，从而注册compile的make钩子

							- MultiEntryPlugin
							- SingleEntryPlugin
							  ```
							  class SingleEntryPlugin {
							      apply(compiler) {
							  
							          compiler.hooks.make.tapAsync(
							              "SingleEntryPlugin",
							              (compilation, callback) => {
							              }
							          );
							      }
							  }
							  ```
							- DynamicEntryPlugin

			- 6. 执行compiler的run方法转换控制权
			  ```
			  compiler.run(callback);
			  
			  // compiler.js
			  run(callback) {
			      const onCompiled = (err, compilation) => {};
			      this.hooks.beforeRun.callAsync(this, err => {
			          this.hooks.run.callAsync(this, err => {
			              this.readRecords(err => {
			                  this.compile(onCompiled);
			              })
			          }
			      })
			  }
			  ```
				- beforeRun、run钩子触发执行
				- beforeCompile、compile钩子触发执行

		- compiler控制

			- 7. 创建编译(compilation)参数
			  ```
			  const params = this.newCompilationParams();
			  
			  newCompilationParams() {
			      const params = {
			          // 通过绝对路径或相对路径，解析一个模块
			          normalModuleFactory: this.createNormalModuleFactory(),
			          // 通过给定的 context 解析一个模块。
			          contextModuleFactory: this.createContextModuleFactory(),
			          compilationDependencies: new Set()
			      };
			      return params;
			  }
			  ```
				- Module分类

					- NormalModule(普通模块)
					- ContextModule(./src/a ./src/b)
					- ExternalModule(module.exports=jQuery)
					- DelegatedModule(manifest)
					- MultiModule(entry:['a', 'b'])

				- 触发beforeCompile、compile钩子执行

			- 8. 实例化Compilation
			  ```
			  const compilation = this.newCompilation(params);
			  
			  createCompilation() {
			      return new Compilation(this);
			  }
			  
			  newCompilation(params) {
			      // 创建 Compilation 实例
			      const compilation = this.createCompilation();
			      compilation.fileTimestamps = this.fileTimestamps;
			      compilation.contextTimestamps = this.contextTimestamps;
			      compilation.name = this.name;
			      compilation.records = this.records;
			      // 触发 compilation 事件之前执行（查看下面的 compilation）。
			      compilation.compilationDependencies = params.compilationDependencies;
			      // 编译(compilation)创建之后，执行插件。
			      this.hooks.thisCompilation.call(compilation, params);
			      this.hooks.compilation.call(compilation, params);
			      return compilation;
			  }
			  ```
				- 创建完compilation对象后触发thisCompilation、compilation钩子

					- EntryOptionPlugin插件会在compilation钩子中添加依赖解析工厂

			- 9. 触发make钩子
			  ```
			  compile(callback) {
			      //......
			      this.hooks.make.callAsync(compilation, err => {
			          //......
			      });
			  }
			  ```
				- 10. 根据entry的配置启动不同的插件(SingleEntryPlugin)
				  ```
				  apply(compiler) {
				      compiler.hooks.make.tapAsync(
				          "SingleEntryPlugin",
				          (compilation, callback) => {
				              const { entry, name, context } = this;
				              const dep = SingleEntryPlugin.createDependency(entry, name);
				              //  make构建阶段开始标志 name = main
				              compilation.addEntry(context, dep, name, callback);
				          }
				      );
				  }
				  
				  static createDependency(entry, name) {
				      const dep = new SingleEntryDependency(entry);
				      dep.loc = { name };
				      return dep;
				  }
				  ```
				- 将控制权交给compilation组件

	- 构建阶段

		- compilation控制

			- 1. 触发Compilation的addEntry方法进行编译
			  ```
			  addEntry(context, entry, name, callback) {
			      // this = compilation
			      this.hooks.addEntry.call(entry, name);
			      // 将模块添加到依赖列表中去，同时进行模块构建。
			      this._addModuleChain(/*参数*/);
			  }
			  ```
			- 2. 执行_addModuleChain添加模块链
			- 3. 获取模块创建工厂 SingleEntryDependency --> normalModuleFactory
				  ```
				  // 获取模块创建工厂 SingleEntryDependency --> normalModuleFactory
				  const moduleFactory = this.dependencyFactories.get(Dep);
			  	  ```
			  
			- 4. 调用moduleFactory的create方法创建模块对象
			  ```
			  this.semaphore.acquire(() => {
			      moduleFactory.create(/**/);
			  });
			  ```
		- normalModuleFactory控制

			- 根据ModuleFactory将entry转换成module

				- 准备阶段

					- 触发ModuleFactory相关钩子

						- 执行create方法，触发beforeResolve钩子回调
						  ```
						  create(data, callback) {
						      this.hooks.beforeResolve.callAsync(/*参数*/);
						  }
						  ```
						- 执行factory钩子
						  ```
						  const factory = this.hooks.factory.call(null);
						  ```

							- 在实例化NormalModuleFactory 对象的时候会注册该钩子的回调
							  ```
							  class NormalModuleFactory extends Tapable {
							      constructor(context, resolverFactory, options) {
							          super();
							          this.hooks.factory.tap("NormalModuleFactory", () => (result, callback) => {/**/});
							          this.hooks.resolver.tap("NormalModuleFactory", () => (data, callback) => {/**/});
							      }
							  }
							  ``` 
							- 返回模块解析工厂，是一个函数
							- 接着执行factory注册的回调逻辑，即执行factory方法

						- 执行resolver钩子
						  ```
						  let resolver = this.hooks.resolver.call(null);
						  ```
						  
							- 同样在实例化NormalModuleFactory 对象的时候会注册该钩子的回调
							- 执行resolver返回的回调函数
							- 收集配置的loader数据，返回内容
							  ```
							  {
							      context: context,
							      request: loaders
							          .map(loaderToIdent)
							          .concat([resource])
							          .join("!"),
							      dependencies: data.dependencies,
							      userRequest,
							      rawRequest: request,
							      loaders,
							      resource,
							      matchResource,
							      resourceResolveData,
							      settings,
							      type,
							      // 为 module 提供 parser，用于解析模块为 ast
							      parser: this.getParser(type, settings.parser),
							      // 为 module 提供 generator，用于模版生成时提供方法
							      generator: this.getGenerator(type, settings.generator),
							      resolveOptions
							  }
							  ```
						- 执行afterResolve钩子
						  ```
						  resolver(result, (err, data) => {
						      this.hooks.afterResolve.callAsync(data, (err, result) => {/**/});
						  });
						  ```
							- 触发createModule钩子回调
							  ```
							  resolver(result, (err, data) => {
							      this.hooks.afterResolve.callAsync(data, (err, result) => {
							          let createdModule = this.hooks.createModule.call(result);
							      /**/});
							  });
							  ```
							- 创建NormalModule实例，收集loader及parser、generator解析器等属性
							  ```
							  createdModule = new NormalModule(result);
							  ```
								- 

							- 触发module钩子执行
							  ```
							  createdModule = this.hooks.module.call(createdModule, result);
							  ```
					- 添加模块执行addModule
					  ```
					  addModule(module, cacheGroup) {
					      debugger;
					      // 获得编译文件的绝对路径
					      const identifier = module.identifier();
					      // 模块是否已经被添加
					      const alreadyAddedModule = this._modules.get(identifier);
					      if (alreadyAddedModule) {
					          return {
					              module: alreadyAddedModule,
					              issuer: false,
					              build: false,
					              dependencies: false
					          };
					      }
					      const cacheName = (cacheGroup || "m") + identifier;
					      // webpack 缓存处理，在多次编译的场景下，以增量变更编译的方式保证编译速度
					      if (this.cache && this.cache[cacheName]) {
					          const cacheModule = this.cache[cacheName];
					  
					          if (typeof cacheModule.updateCacheModule === "function") {
					              cacheModule.updateCacheModule(module);
					          }
					  
					          let rebuild = true;
					          // 判断是否需要重新编译
					          if (this.fileTimestamps && this.contextTimestamps) {
					              rebuild = cacheModule.needRebuild(
					                  this.fileTimestamps,
					                  this.contextTimestamps
					              );
					          }
					  
					          if (!rebuild) {
					              cacheModule.disconnect();
					              this._modules.set(identifier, cacheModule);
					              this.modules.push(cacheModule);
					              for (const err of cacheModule.errors) {
					                  this.errors.push(err);
					              }
					              for (const err of cacheModule.warnings) {
					                  this.warnings.push(err);
					              }
					              return {
					                  module: cacheModule,
					                  issuer: true,
					                  build: false,
					                  dependencies: true
					              };
					          }
					          cacheModule.unbuild();
					          module = cacheModule;
					      }
					      this._modules.set(identifier, module);
					      if (this.cache) {
					          this.cache[cacheName] = module;
					      }
					      this.modules.push(module);
					      return {
					          module: module,
					          issuer: true,
					          build: true,
					          dependencies: true
					      };
					  }
					  ```
						- 判断模块是否已经被添加

							- 如果已经添加则直接从全局的_modules缓存中取
							- 没有则将其添加到_modules缓存中，并构造module对象返回设置build标志为false

						- 处理webpack的编译缓存

					- 最终给build阶段准备的数据
					  ```
					  result = {
					      context: context,
					      request: loaders
					          .map(loaderToIdent)
					          .concat([resource])
					          .join("!"),
					      dependencies: data.dependencies,
					      userRequest,
					      rawRequest: request,
					      loaders,
					      resource,
					      matchResource,
					      resourceResolveData,
					      settings,
					      type,
					      // 为 module 提供 parser，用于解析模块为 ast
					      parser: this.getParser(type, settings.parser),
					      // 为 module 提供 generator，用于模版生成时提供方法
					      generator: this.getGenerator(type, settings.generator),
					      resolveOptions
					  }
					  ```
				- build阶段

					- 执行buildModule逻辑
					  ```
					  _addModuleChain(context, dependency, onModule, callback) {
					      this.semaphore.acquire(() => {
					          moduleFactory.create(
					              {/**/},
					              (err, module) => {
					                  // 如果是初次加载的话，不在缓存中则build返回true
					                  if (addModuleResult.build) {
					                      // 构建模块
					                      this.buildModule(/**/);
					                  }
					              }
					          );
					      });
					  }
					  ```
						- 触发buildModule钩子执行
						  ```
						  buildModule(module, optional, origin, dependencies, thisCallback) {
						      this.hooks.buildModule.call(module);
						      module.build(/**/);
						  }
						  ```
						- 执行NormalModule的build逻辑
						  ```
						  build(options, compilation, resolver, fs, callback) {
						      return this.doBuild(/**/);
						  }
						  ```
							- 根据loader-runner进行资源加载执行loader转换逻辑
							  ```
							  doBuild(options, compilation, resolver, fs, callback) {
							      // 创建加载上下文
							      const loaderContext = this.createLoaderContext(
							          resolver,
							          options,
							          compilation,
							          fs
							      );
							      // 根据文件的加载规则，进行文件加载
							      runLoaders(/**/);
							  }
							  ```
							- 调用acorn将module转换成AST
							  ```
							  parse(source, initialState) {
							      let ast;
							      let comments;
							      // source 是字符串
							      if (typeof source === "object" && source !== null) {
							      } else {
							          comments = [];
							          ast = Parser.parse(source, {
							              sourceType: this.sourceType,
							              onComment: comments
							          });
							      }
							  }
							  
							  static parse(code, options) {
							      try {
							          // 调用 acorn 插件进行转换
							          ast = acornParser.parse(code, parserOptions);
							      } catch (e) {
							      }
							  }
							  ```
								- 

						- 触发succeedModule钩子执行

						  this.hooks.succeedModule.call(module);
						  
					- buildModule成功后执行回调方法afterBuild
					  ```
					  _addModuleChain(context, dependency, onModule, callback) {
					      this.semaphore.acquire(() => {
					          moduleFactory.create(
					              {/*.....*/},
					              (err, module) => {
					                  const afterBuild = () => {
					                      // 递归处理依赖
					                      if (addModuleResult.dependencies) {
					                          this.processModuleDependencies(module, err => {
					                              if (err) return callback(err);
					                              callback(null, module);
					                          });
					                      }
					                  };
					  
					                  // 如果是初次加载的话，不在缓存中则build返回true
					                  if (addModuleResult.build) {
					                      // 构建模块
					                      this.buildModule(module, false, null, null, err => {
					                          /*.....*/
					                          afterBuild();
					                      });
					                  }
					              }
					          );
					      });
					  }
					  ```
						- 调用 processModuleDependencies 处理依赖
						  ```
						  processModuleDependencies(module, callback) {
						      const dependencies = new Map();
						  
						      const addDependency = dep => {};
						  
						      const addDependenciesBlock = block => {
						          // 同步依赖
						          if (block.dependencies) {
						              iterationOfArrayCallback(block.dependencies, addDependency);
						          }
						          // 异步依赖
						          if (block.blocks) {
						              iterationOfArrayCallback(block.blocks, addDependenciesBlock);
						          }
						          if (block.variables) {
						              iterationBlockVariable(block.variables, addDependency);
						          }
						      };
						  
						      try {
						          // 处理模块依赖
						          addDependenciesBlock(module);
						      } catch (e) {
						          callback(e);
						      }
						      this.addModuleDependencies(/**/);
						  }
						  ```
							- 同步依赖存储在 module的dependencies属性中
							- 异步依赖存储在 module 的blocks属性中
							- 执行addModuleDependencies方法，添加模块依赖

						- 如果模块还存在依赖则会接着调用afterBuild方法

	- 生成阶段

		- 进入seal阶段

			- 激活 seal 钩子
			- 触发模块依赖优化阶段

				- 触发optimizeDependencies钩子执行

			- 处理chunk

				- 触发 beforeChunks 钩子
				- 遍历每个入口创建chunk对象，异步module创建一个独立的chunk

					- 分析每个模块之间的关系 - 为异步module单独建立一个chunkGroup
					- 建立异步chunk和异步chunkGroup之间的联系、建立异步chunkGroup与chunkGroup之间的联系
					- 清理工作

				- 触发 afterChunks 钩子

			- 优化操作

				- 优化module

					- optimizeModules

				- 优化chunk

					- 触发各种优化操作 - optimizeChunks
					- optimizeChunksAdvanced

						- SplitChunksPlugin

		- 调用emitAssets 写入文件

- 编译优化

	- 分析量化

		- 体积分析

			- webpack --profile --json > stats.json 生成文件
			- 使用 webpack-bundle-analyzer 对生成的文件进行打包内容分析

		- 速度分析
		  ```
		  // config/webpack.common.js
		  const SpeedMeasurePlugin = require("speed-measure-webpack-plugin");
		  const smp = new SpeedMeasurePlugin();
		  // ...
		  module.exports = (production) => {
		    if (production) {
		      const endProdConfig = merge(commonConfig, prodConfig);
		      return smp.wrap(endProdConfig);
		    } else {
		      const endDevConfig = merge(commonConfig, devConfig);
		      return smp.wrap(endDevConfig);
		    }
		  };
		  ```
		  
			- speed-measure-webpack-plugin分析总时间以及每个loader和plugin的打包时间

	- 优化策略

		- webpack自身相关

			- babel 配置的优化

				- @babel/plugin-transform-runtime

					- 转译代码，然后通过引入@Babel/runtime-corejs3，解决通过修改原型来进行pollfill和在定义同一模块引入

			- 使用新版本的webpack

		- 体积优化

			- CSS相关

				- 使用mini-css-extract-plugin替换style-loader进行CSS的抽离操作
				  ```
				  const MiniCssExtractPlugin = require("mini-css-extract-plugin");
				   {
				   test: /\.less$/,
				   use: [
				   // "style-loader", // 不再需要style-loader，使用MiniCssExtractPlugin.loader代替
				    MiniCssExtractPlugin.loader,
				    "css-loader", // 编译css
				    "postcss-loader",
				    "less-loader" // 编译less
				   ]
				   },
				  plugins: [
				    new MiniCssExtractPlugin({
				     filename: "css/[name]_[contenthash:6].css",
				     chunkFilename: "[id].css"
				    })
				   ]
				  ```
				  
				- 使用optimize-css-assets-webpack-plugin和cssnano压缩CSS

			- HTML

				- 使用html-webpack-plugin处理HTML内容 - 压缩、删除注释等
				  ```
				  new htmlWebpackPlugin({
				     title: "京东商城",
				     template: "./index.html",
				     filename: "index.html",
				     minify: {
				       // 压缩HTML文件
				       removeComments: true, // 移除HTML中的注释
				       collapseWhitespace: true, // 删除空白符与换行符
				       minifyCSS: true // 压缩内联css
				    }
				   }),
				  ```
				  
			- JS

				- 配置多个入口进行代码分离
				- 使用SplitChunksPlugin抽取公共代码
				  ```
				  module.exports = {
				    optimization: {
				      splitChunks: {
				        chunks: 'async', // 只对异步加载的模块进行拆分，import('jquery').then()就是典型的异步加载，可选项还有 all | initial
				        minSize: 30000, // 模块最少大于 30kb 才会拆分
				        maxSize: 0, // 为0时模块大小无上限，只要大于 30kb 都会拆分。若是非0，超过了maxSize的值，会进一步拆分
				        minChunks: 1, // 模块最少引用一次才会拆分
				        maxAsyncRequests: 5, // 异步加载时同时发送的请求数量最大不能超过5，超过5的部分不拆分
				        maxInitialRequests: 3, // 页面初始化时，同时发送的请求数量最大不能超过3，超过3的不跟不拆分
				        automaticNameDelimiter: '~', // 默认的连接符
				        name: true, // 拆分的chunk名，设置为true表示根据模块名和CacheGroup的key来自动生成，使用上面的连接符连接
				        cacheGroups: { // 缓存组配置，上面配置读取完成后进行拆分，如果需要把多个模块拆分到一个文件，就需要缓存，所以命名为缓存组
				          vendors: { // 自定义缓存组名
				            test: /[\\/]node_modules[\\/]/, // 检查 node_modules 目录，只要模块在该目录下就使用上面配置拆分到这个组
				            priority: -10, // 权重为-10，决定了那个组优先匹配，假如node_modules下面有个模块要拆分，同时满足vendors和default组，此时就会分到 priority 值比较大的组，因为 -10 > -20 所以分到 vendors 组
				            filename:'vendoes.js'
				          },
				          default: { // 默认缓存组名
				            minChunks: 2, // 最少引用两次才会被拆分
				            priority: -20, // 权重 -20
				            reuseExistingChunk: true // 如果主入口中引入了两个模块，其中一个正好也引用了后一个，就会直接复用，无需引用两次
				          }
				        }
				      }
				    }
				  };
				  ```
				  
				- externals优化静态资源
				  ```
				  <script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
				  
				  //webpack.config.js
				  module.exports = {
				   //...
				   externals: {
				   //jquery通过script引入之后，全局中即有了 jQuery 变量
				   'jquery': 'jQuery'
				   }
				  }
				  ```
				  
					- 首先使用CDN加载静态资源
					- 其次通过externals配置全局变量

				- 懒加载

					- import、babel插件

		- 速度优化

			- Loader的优化

				- 配合test、include、exclude缩小loader范围
				  ```
				  {
				      test: /\.js$/,
				      include: path.resolve(__dirname, "./src"), 
				      exclude: /node_modules/,
				      use: { loader: "babel-loader"}
				  }
				  ```
			- resolve的配置优化

				- 通过配置modules指明直接查找第三方包的位置
				  ```
				  module.exports = {
				      resolve: {
				          modules: [path.resolve(__dirname, "./node_modules")]
				      }
				  }
				  ```
				  
					- 先在项目根目录下的node_modules中找，没有则找父目录

				- 通过alias指明依赖解析的地址，避免查找开销
					```
				    resolve: {
				      //查找第三方优化
				      modules: [path.resolve(__dirname, "./node_modules")],
				      alias: {
				        "@": path.join(__dirname, "./src"),
				        react: path.resolve(__dirname, "./node_modules/react/umd/react.production.min.js"),
				      },
				    },
				    ```
				  
				- 通过配置 extensions 选项，会给没有后缀的文件加上后缀后再进行查找

			- 使用thead-loader
			  ```
			  module.exports = {
			    module: {
			      rules: [
			        {
			          test: /\.js$/,
			          include: path.resolve('src'),
			          use: [
			            "thread-loader",
			            // 耗时的 loader （例如 babel-loader）
			          ],
			        },
			      ],
			    },
			  };
			  ```
			  
				- 需要将此loader放到其他loader之前，放到这个之后的loader会在一个独立的worker池中运行
				- worker 池中运行的 loader 是受到限制

					- 这些 loader 不能生成新的文件
					- 这些 loader 无法获取 webpack 的配置
					- 这些 loader 不能使用自定义的 loader API

				- 每个 worker 都是一个独立的 node.js 进程，其开销大约为 600ms 左右。同时会限制跨进程的数据交换

			- 使用插件DLLPlugin插件预先编译资源模块
			- 开启 loader 和 plugin 的缓存

				- 通过参数 cacheDirectory = true 开启babel-loader的缓存
				  ```
				  // config/webpack.common.js
				  module: {
				    rules: [
				      { 
				        test: /\.jsx?$/, 
				        use: [
				          {
				            loader: 'babel-loader',
				            options: {
				              cacheDirectory: true,
				            }
				          },
				        ]
				      },
				    ]
				  }  
				  ```
				  
					- 在./node_modules/.cache中会存储babel的缓存文件

				- TerserPlugin 开启压缩缓存
				  ```
				  // config/webpack.common.js
				  const TerserPlugin = require('terser-webpack-plugin');
				  // ...
				  const commonConfig = {
				    // ...
				    optimization: {
				      minimize: true,
				      minimizer: [
				        new TerserPlugin({
				          parallel: 4, // 开启几个进程来处理压缩，默认是 os.cpus().length - 1
				          cache: true,
				        }),
				      ],
				    },
				    // ...
				  }
				  ```
				  
					- 缓存文件 node_modules/.cache/terser-webpack-plugin

				- hard-source-webpack-plugin缓存
				  ```
				  //webpack.config.js
				  var HardSourceWebpackPlugin = require('hard-source-webpack-plugin');
				  module.exports = {
				      //...
				      plugins: [
				          new HardSourceWebpackPlugin()
				      ]
				  }
				  ```
				  
					- 为模块提供中间缓存
					- 缓存默认的存放路径是: node_modules/.cache/hard-source

			- noParse
			  ```
			  //webpack.config.js
			  module.exports = {
			      //...
			      module: {
			          noParse: /jquery|lodash/
			      }
			  }
			  ```
			  
				- 使用此声明可以告诉webpack引入该模块但不进行转换和解析
				- 一个正则表达式或者是一个 function

- HMR

	- 代码编译阶段
	  ```
	  function startDevServer(config, options) {
	      let compiler;
	  
	      try {
	          // 1. 生成webpack编译主引擎 compiler
	          compiler = webpack(config);
	      } catch (err) {}
	  
	      try {
	          // 2. 启动本地服务，启动watch编译
	          server = new Server(compiler, options, log);
	          serverData.server = server;
	      } catch (err) {}
	  
	      if (options.socket) {} else {
	          // 3. 启动监听
	          server.listen(options.port, options.host, (err) => {});
	      }
	  }
	  ```
		- 创建compiler实例
		  ```
		  const webpack = (options, callback) => {
		      const webpackOptionsValidationErrors = validateSchema(
		          webpackOptionsSchema,
		          options
		      );
		      if (webpackOptionsValidationErrors.length) {
		          throw new WebpackOptionsValidationError(webpackOptionsValidationErrors);
		      }
		      let compiler;
		      if (Array.isArray(options)) {
		          compiler = new MultiCompiler(
		              Array.from(options).map(options => webpack(options))
		          );
		      } else if (typeof options === "object") {
		          // 1. 传入的参数和默认参数进行合并成为新的options
		          options = new WebpackOptionsDefaulter().process(options);
		          // 2. 创建compiler，以及相关plugin
		          compiler = new Compiler(options.context);
		          compiler.options = options;
		          // 3. 监听 beforeRun 钩子，它的作用是清除缓存
		          new NodeEnvironmentPlugin({
		              infrastructureLogging: options.infrastructureLogging
		          }).apply(compiler);
		  
		          // 4. 监听第三方插件添加的钩子
		          if (options.plugins && Array.isArray(options.plugins)) {
		              for (const plugin of options.plugins) {
		                  if (typeof plugin === "function") {
		                      plugin.call(compiler, compiler);
		                  } else {
		                      plugin.apply(compiler);
		                  }
		              }
		          }
		  
		          // 5. 触发environment、afterEnvironment钩子事件
		          compiler.hooks.environment.call();
		          // -- WatchIgnorePlugin 插件会加入监听
		          compiler.hooks.afterEnvironment.call();
		          // 6. 实例化默认插件列表
		          compiler.options = new WebpackOptionsApply().process(options, compiler);
		      } else {
		          throw new Error("Invalid argument: options");
		      }
		      return compiler;
		  };
		  ```
		- 创建服务
		  ```
		  class Server {
		    constructor(compiler, options = {}, _log) {
		      ///////// 修改webpack.config.js的entry配置 ******
		      updateCompiler(this.compiler, this.options);
		  
		      // 绑定监听事件
		      this.setupHooks();
		      // 使用express框架启动本地server，让浏览器可以请求本地的静态资源
		      this.setupApp();
		  
		      // webpack监听文件变化
		      this.setupDevMiddleware();
		  
		      // set express routes
		      routes(this);
		  
		      // 启动websocket服务
		      this.createServer();
		    }
		  }
		  ```
			- updateCompiler -> addEntries： 添加entry配置项
			  ```
			  function updateCompiler(compiler, options) {
			      // 修改webpack.config.js的entry配置
			      addEntries(webpackConfig, options);
			  }
			  ```
				- 启动一个socket客户端，绑定一些回调操作，进行热替换操作

					- xxx/node_modules/webpack-dev-server/client/index.js

				- 使用node 的emitter 添加一个webpackHotUpdate 事件监听器
				  ```
				  if (module.hot) {
				      var hotEmitter = require("./emitter");
				      // 监听 webpackHotUpdate 事件
				      hotEmitter.on("webpackHotUpdate", function(currentHash) {});
				  }
				  ```
					- xxx/node_modules/webpack/hot/dev-server.js

			- **setupHooks：注册compiler的done钩子回调**
			  ```
			  setupHooks() {
			      const addHooks = (compiler) => {
			          const { compile, invalid, done } = compiler.hooks;
			          // 监听webpack的done钩子，tapable提供的监听方法
			          done.tap('webpack-dev-server', (stats) => {
			              // 给浏览器发送通知，ok和hash事件
			              this._sendStats(this.sockets, this.getStats(stats));
			              this._stats = stats;
			          });
			      };
			  
			      if (this.compiler.compilers) {} else {
			          addHooks(this.compiler);
			      }
			  }
			  ```
			- setupApp：初始化一个Express服务器

			  setupApp() {
			      // Init express server
			      // eslint-disable-next-line new-cap
			      this.app = new express();
			  }
			  
			- setupDevMiddleware：初始化webpack-dev-middleware中间件

			  setupDevMiddleware() {
			      // middleware for serving webpack bundle
			      this.middleware = webpackDevMiddleware(
			          this.compiler,
			          Object.assign({}, this.options, { logLevel: this.log.options.level })
			      );
			  }
			  
			  
			  // webpack-dev-middleware
			  module.exports = function wdm(compiler, opts) {
			    const options = Object.assign({}, defaults, opts);
			  
			    const context = createContext(compiler, options);
			  
			    // start watching
			    if (!options.lazy) {
			  
			      /* 首先对本地文件代码进行编译打包，也就是webpack的一系列编译流程
			       * 其次编译结束后，开启对本地文件的监听，当文件发生变化，重新编译，编译完成之后继续监听。
			       */
			      context.watching = compiler.watch(options.watchOptions, (err) => {});
			    }
			  
			    // 通过“memory-fs”库将打包后的文件写入内存
			    setFs(context, compiler);
			  
			    return Object.assign(middleware(context), {});
			  };
			  
				- 执行 compiler.watch 操作

				  watch(watchOptions, handler) {
				      // 是否正则运行watch
				      if (this.running) return xxx;
				      this.running = true;
				      return new Watching(this, watchOptions, handler);
				  }
				  
					- 创建Watching实例

					  class Watching {
					      constructor(compiler, watchOptions, handler) {
					          this.running = true;
					          this.compiler.readRecords(err => {
					              this._go();
					          });
					      }
					  
					  
					  
					- 启动编译

					      _go() {
					          this.compiler.hooks.watchRun.callAsync(this.compiler, err => {
					              const onCompiled = (err, compilation) => {/**/};
					              this.compiler.compile(onCompiled);
					          });
					      }
					  }
					  
						- 创建socket客户端，执行/webpack-dev-server/client/index.js代码

						  // 设置消息处理对象函数
						  var onSocketMessage = {
						    hash: function hash(_hash) {
						      status.currentHash = _hash;
						    },
						    ok: function ok() {
						      sendMessage('Ok');
						      // 进行更新检查等操作
						      reloadApp(options, status);
						    }
						  };
						  
						  /*
						   * 连接服务地址socketUrl，?http://localhost:8080，本地服务地址
						   * hash事件，更新最新一次打包后的hash值。
						   * ok事件，进行热更新检查。
						   */
						  socket(socketUrl, onSocketMessage);
						  
							- 添加ok事件，进行热更新检查。
							- 添加hash事件，更新最新一次打包后的hash值

						- 执行/webpack/hot/dev-server.js代码，添加监听

						  if (module.hot) {
						      var hotEmitter = require("./emitter");
						      // 监听 webpackHotUpdate 事件
						      hotEmitter.on("webpackHotUpdate", function(currentHash) {});
						  }
						  
						- 执行 HotModuleReplacementPlugin 插件中相关钩子

						  mainTemplate.hooks.bootstrap.tap(
						      "HotModuleReplacementPlugin",
						      (source, chunk, hash) => {
						          source = mainTemplate.hooks.hotBootstrap.call(source, chunk, hash);
						          return Template.asString([
						              source,
						              "",
						              hotInitCode // 添加 hotCreateModule 方法
						                  .replace(/\$require\$/g, mainTemplate.requireFn)
						                  .replace(/\$hash\$/g, JSON.stringify(hash))
						                  .replace(/\$requestTimeout\$/g, requestTimeout)
						                  .replace(
						                      /\/\*foreachInstalledChunks\*\//g,
						                      needChunkLoadingCode(chunk)
						                          ? "for(var chunkId in installedChunks)"
						                          : `var chunkId = ${JSON.stringify(chunk.id)};`
						                  )
						          ]);
						      }
						  );
						  
						  mainTemplate.hooks.moduleObj.tap(
						      "HotModuleReplacementPlugin",
						      (source, chunk, hash, varModuleId) => {
						          return Template.asString([
						              `${source},`,
						              `hot: hotCreateModule(${varModuleId}),`,
						              "parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),",
						              "children: []"
						          ]);
						      }
						  );
						  
							- 给客户端代码添加 module.hot.check 和 module.hot.apply 方法

							  {
							      hot: {
							          hotCreateModule: () => ({
							              check: hotCheck,
							              apply: hotApply,
							          })
							      }
							  }
							  
							- 添加compilation的additionalChunkAssets钩子 -给编译后的module包装一层webpackHotUpdate方法，在通过jsonp获取此次增量module时候会被执行

							  compilation.hooks.additionalChunkAssets.tap(
							      "HotModuleReplacementPlugin",
							      () => {
							          /*
							          records: {
							              chunkHashs: {
							                  main: "4504750bf73b2923afe3d74ebb93a69b"
							              },
							              chunkModuleIds: {
							                  main: (36) [0, ..., "./src/hello.js", "./src/index.js"]
							              }
							              chunks: {byName: {…}, bySource: {…}, usedIds: Array(0)}
							              hash: "796eb08d1bb8742e527d"
							              moduleHashs: {...}
							              modules: {byIdentifier: {…}, usedIds: {…}}
							              preHash: "50b6ca607c819dd60ada"
							              prepreHash: "796eb08d1bb8742e527d"
							          }
							           */
							          const records = compilation.records;
							          if (records.hash === compilation.hash) return;
							          if (
							              !records.moduleHashs ||
							              !records.chunkHashs ||
							              !records.chunkModuleIds
							          )
							              return;
							          // 通过hotUpdate属性标记module是否本次更新的文件
							          for (const module of compilation.modules) {
							              const identifier = module.identifier();
							              let hash = module.hash;
							              module.hotUpdate = records.moduleHashs[identifier] !== hash;
							          }
							          /**/
							          // records.chunkHashs = {main: "4504750bf73b2923afe3d74ebb93a69b"}
							          for (const key of Object.keys(records.chunkHashs)) {
							              /**/
							              const newModules = currentChunk
							                      .getModules()
							                      .filter(module => module.hotUpdate);
							              if (newModules.length > 0 || removedModules.length > 0) {
							                  // 处理需要热更新的模块 - HotUpdateChunkTemplate
							                  const source = hotUpdateChunkTemplate.render(/**/);
							                  /**/
							              }
							          }
							          /**/
							      }
							  );
							  
							  HotUpdateChunkTemplate
							  
							  render(
							      id,
							      modules,
							      removedModules,
							      hash,
							      moduleTemplate,
							      dependencyTemplates
							  ) {
							      // JsonpHotUpdateChunkTemplatePlugin - webpackHotUpdate(\"main\",
							      const source = this.hooks.render.call(/**/);
							      return source;
							  }
							  
							  class JsonpHotUpdateChunkTemplatePlugin {
							      apply(hotUpdateChunkTemplate) {
							          hotUpdateChunkTemplate.hooks.render.tap(
							              "JsonpHotUpdateChunkTemplatePlugin",
							              (modulesSource, modules, removedModules, hash, id) => {
							                  const source = new ConcatSource();
							                  // hotUpdateChunkTemplate.outputOptions.hotUpdateFunction = webpackHotUpdate(\"main\",
							                  source.add(
							                      `${
							                          hotUpdateChunkTemplate.outputOptions.hotUpdateFunction
							                      }(${JSON.stringify(id)},`
							                  );
							                  source.add(modulesSource);
							                  source.add(")");
							                  return source;
							              }
							          );
							      }
							  }
							  
				- 设置写入文件到内存中

				  setFs(context, compiler) {
				      // MemoryFileSystem -- memory-fs
				      fileSystem = new MemoryFileSystem();
				      compiler.outputFileSystem = fileSystem;
				      context.fs = fileSystem;
				  }
				  
			- 给express服务添加路由
			- createServer：创建 http服务器

			  createServer() {
			      // 创建服务器
			      this.listeningApp = http.createServer(this.app);
			  }
			  
		- listen：启动http服务，触发监听操作-创建socket服务器

		  listen(port, hostname, fn) {
		      this.hostname = hostname;
		  
		      return this.listeningApp.listen(port, hostname, (err) => {
		          // 创建 Socket 服务器
		          this.createSocketServer();
		      });
		  }
		  
		  createSocketServer() {
		      const SocketServerImplementation = this.socketServerImplementation;
		      this.socketServer = new SocketServerImplementation(this);
		  
		      this.socketServer.onConnection((connection, headers) => {
		          this.sockets.push(connection);
		      });
		  }
		  
	- 编译完成触发done事件

	  done.tap('webpack-dev-server', (stats) => {
	      // 给浏览器发送通知，ok和hash事件
	      this._sendStats(this.sockets, this.getStats(stats));
	      this._stats = stats;
	  });
	  
		- socket服务器给客户端发送数据

			- socket 服务器给socket客户端发送当前编译的hash事件，数据即是当前编译的hash、
同时发送ok事件

			  _sendStats(sockets, stats, force) {
			      this.sockWrite(sockets, 'hash', stats.hash);
			      this.sockWrite(sockets, 'ok');
			  }
			  
			  sockWrite(sockets, type, data) {
			      sockets.forEach((socket) => {
			          this.socketServer.send(socket, JSON.stringify({ type, data }));
			      });
			  }
			  
		- socket客户端收到事件

			- hash

			  hash: function hash(_hash) {
			      status.currentHash = _hash;
			  }
			  
				- 保存currentHash

			- ok

			  ok: function ok() {
			      sendMessage('Ok');
			      // 进行更新检查等操作
			      reloadApp(options, status);
			  }
			  
				- 客户端给服务端返回ok消息？？？
				- 客户端更新检查 - reloadApp

				  function reloadApp(_ref, _ref2) {
				  
				      if (hot) {
				          var hotEmitter = require('webpack/hot/emitter');
				          // 利用node.js的EventEmitter，发出webpackHotUpdate消息
				          // 更好的维护代码，以及职责划分的更明确。websocket仅仅用于客户端（浏览器）和服务端进行通信。而真正做事情的活还是交回给了webpack
				          hotEmitter.emit('webpackHotUpdate', currentHash);
				      }
				  }
				  
					- 使用EventEmitter发送webpackHotUpdate消息，webpack的dev-server会监听webpackHotUpdate消息

						- websocket仅仅用于客户端（浏览器）和服务端进行通信。
而真正做事情的活还是交回给了webpack

	- dev-server执行热更新检查

	  var check = function check() {
	      // module.hot.check方法哪里定义的？？？？ -- 通过插件 HotModuleReplacementPlugin 生成
	      module.hot
	          .check(true)
	          .then(function(updatedModules) {
	              if (!upToDate()) {
	                  check();
	              }
	          });
	  };
	  
		- 执行HotModuleReplacement.runtime.js 文件中定义的 hotCheck

		  function hotCheck(apply) {
		      // 调用hotDownloadManifest发送xxx/hash.hot-update.json的ajax请求； -- 使用JSONP进行更新
		      return hotDownloadManifest(hotRequestTimeout).then(/**/);
		  }
		  
			- 调用hotDownloadManifest获取xxx/hash.hot-update.json文件，包含本次需要更新的module及下次使用的hash值

			  function hotDownloadManifest(requestTimeout) {
			      requestTimeout = requestTimeout || 10000;
			      return new Promise(function(resolve, reject) {
			          try {
			              var request = new XMLHttpRequest();
			              // xxxxxxx.hot-update.json
			              var requestPath = $require$.p + $hotMainFilename$;
			              request.open("GET", requestPath, true);
			              request.timeout = requestTimeout;
			              request.send(null);
			          } catch (err) {}
			          request.onreadystatechange = function() {
			              // success
			              try {
			                  var update = JSON.parse(request.responseText);
			              } catch (e) {}
			              resolve(update);
			          };
			      });
			  }
			  
				- 获取需要更新的文件和下次更新的hash值
				- 返回的数据结构，c表示需要更新的模块，h表示下次热更新hash值

				  {
				      c: {
				          main: true
				      },
				      h: 'xxxxxx'
				  }
				  
				  
			- 服务器返回hot-update.json文件后，取出需要更新的module和hash，进行缓存

			  hotDownloadManifest(hotRequestTimeout).then(function(update) {
			  
			      // 需要更新的文件
			      hotAvailableFilesMap = update.c;
			      // 更新下次热更新hash值
			      hotUpdateNewHash = update.h;
			      // 进入热更新准备状态
			      {
			          // 调用hotDownloadUpdateChunk发送xxx/hash.hot-update.js 请求，通过JSONP方式。
			          hotEnsureUpdateChunk(chunkId);
			      }
			  });
			  
			- 调用hotDownloadUpdateChunk发送xxx/hash.hot-update.js 请求，通过JSONP方式。

			  function hotDownloadUpdateChunk(chunkId) {
			      var script = document.createElement("script");
			      script.charset = "utf-8";
			      script.src = $require$.p + $hotChunkFilename$;
			      if ($crossOriginLoading$) script.crossOrigin = $crossOriginLoading$;
			      document.head.appendChild(script);
			  }
			  
		- xxx/hash.hot-update.js返回的js文件会被webpackHotUpdate方法进行包装

		  webpackHotUpdate(\"main\", {"./src/index.js": function() {/*.....*/}})
		  
		- 执行上面的JS文件即进行更新

		  window["webpackHotUpdate"] = function webpackHotUpdateCallback(chunkId, moreModules) {
		      hotAddUpdateChunk(chunkId, moreModules);
		  };
		  
		  
		  // \\node_modules\\webpack\\lib\\HotModuleReplacement.runtime.js
		  function hotAddUpdateChunk(chunkId, moreModules) {
		  
		      hotRequestedFilesMap[chunkId] = false;
		      // 更新的模块moreModules赋值给全局全量hotUpdate
		      // 遍历chunk中需要更新的module
		      for (var moduleId in moreModules) {
		          if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
		              hotUpdate[moduleId] = moreModules[moduleId];
		          }
		      }
		      if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
		          hotUpdateDownloaded(); // 调用hotApply进行代码的替换
		      }
		  }
		  
		  function hotUpdateDownloaded() {
		      /**/
		      if (hotApplyOnUpdate) {
		          Promise.resolve()
		              .then(function() {
		                  return hotApply(hotApplyOnUpdate);
		              })
		              .then(/**/);
		      }
		  }
		  
		  function hotApply(options) {
		      return hotApplyInternal(options);
		  }
		  
		  function hotApplyInternal(options) {
		  
		      var cb;
		      var i;
		      var j;
		      var module;
		      var moduleId;
		  
		      function getAffectedStuff(updateModuleId) {
		          /**/
		          // 过期的模块和依赖
		          return {
		              type: "accepted",
		              moduleId: updateModuleId,
		              outdatedModules: outdatedModules,
		              outdatedDependencies: outdatedDependencies
		          };
		      }
		  
		      function addAllToSet(a, b) {
		          for (var i = 0; i < b.length; i++) {
		              var item = b[i];
		              if (a.indexOf(item) === -1) a.push(item);
		          }
		      }
		  
		      // at begin all updates modules are outdated
		      // the "outdated" status can propagate to parents if they don't accept the children
		      var outdatedDependencies = {};
		      var outdatedModules = [];
		      var appliedUpdate = {};
		  
		      /*
		          hotUpdate: {
		              './src/index.js': {}
		          }
		      */
		      for (var id in hotUpdate) {
		          if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
		              moduleId = toModuleId(id);
		              /** @type {TODO} */
		              var result;
		              if (hotUpdate[id]) {
		                  result = getAffectedStuff(moduleId);
		              }
		              /** @type {Error|false} */
		              var abortError = false;
		              var doApply = false;
		              var doDispose = false;
		              var chainInfo = "";
		              // result.chain = ['./src/index.js', '0']
		              if (result.chain) {
		                  chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
		              }
		              switch (result.type) {
		                  case "self-declined":/*...*/break;
		                  case "declined":/*...*/break;
		                  case "unaccepted":/*...*/break;
		                  case "accepted":
		                      if (options.onAccepted) options.onAccepted(result);
		                      doApply = true;
		                      break;
		                  case "disposed":/*...*/break;
		              }
		              // 执行更新 - 找出需要更新的module及module的依赖
		              if (doApply) {
		                  appliedUpdate[moduleId] = hotUpdate[moduleId];
		                  addAllToSet(outdatedModules, result.outdatedModules);
		              }
		          }
		      }
		  
		      // Store self accepted outdated modules to require them later by the module system
		      var outdatedSelfAcceptedModules = [];
		      for (i = 0; i < outdatedModules.length; i++) {
		          moduleId = outdatedModules[i];
		          if (
		              installedModules[moduleId] &&
		              installedModules[moduleId].hot._selfAccepted &&
		              // removed self-accepted modules should not be required
		              appliedUpdate[moduleId] !== warnUnexpectedRequire &&
		              // when called invalidate self-accepting is not possible
		              !installedModules[moduleId].hot._selfInvalidated
		          ) {
		              // 存储了被删掉的模块id，便于更新代码
		              outdatedSelfAcceptedModules.push({
		                  module: moduleId,
		                  parents: installedModules[moduleId].parents.slice(),
		                  errorHandler: installedModules[moduleId].hot._selfAccepted
		              });
		          }
		      }
		  
		      // Now in "dispose" phase
		      // 删除过期的模块、过期的依赖阶段
		      var queue = outdatedModules.slice();
		      while (queue.length > 0) {
		          moduleId = queue.pop();
		          //  删除过期模块
		          delete installedModules[moduleId];
		          // 删除过期的依赖
		          delete outdatedDependencies[moduleId];
		      }
		      // Now in "apply" phase
		      // 添加新的模块阶段
		      // 3. 通过__webpack_require__执行相关模块的代码
		      for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
		          var item = outdatedSelfAcceptedModules[i];
		          moduleId = item.module;
		          hotCurrentParents = item.parents;
		          hotCurrentChildModule = moduleId;
		          try {
		              // 执行最新的代码
		              $require$(moduleId);
		          } catch (err) {}
		      }
		  }
		  
			- 找出过期的模块和依赖了该module的module
			- 删除过期的模块、过期的依赖该module的module
			- 添加新的模块
			- 通过__webpack_require__执行相关模块的代码

			  for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
			      var item = outdatedSelfAcceptedModules[i];
			      moduleId = item.module;
			      hotCurrentParents = item.parents;
			      hotCurrentChildModule = moduleId;
			      try {
			          // 执行最新的代码
			          $require$(moduleId);
			      } catch (err) {}
			  }
			  
- tree shaking

	- 使用ES6的import语法，生产模式下会自动移除未用的代码

- tapable

	- 分类

		- 同步钩子

			- SyncHook

				- 同步钩子，钩子订阅者按照顺序一个一个执行

			- SyncBailHook

			  ```
			  const { SyncBailHook } = require('tapable');
			  
			  // 创建实列
			  const syncBailHook = new SyncBailHook(["name", "age"]);
			  
			  // 注册事件
			  syncBailHook.tap("1", (name, age) => {
			    console.log("1", name, age);
			  });
			  
			  syncBailHook.tap("bail", (name, age) => {
			    console.log("bail", name, age);
			    return 'bail';
			  });
			  
			  syncBailHook.tap("3", (name, age) => {
			    console.log("3", name, age);
			  });
			  
			  // 触发事件，让监听函数执行
			  syncBailHook.call("SyncBailHook", 18);
			  ```
			  输出：
			  ```
			  1 SyncBailHook 18
			  bail SyncBailHook 18
			  ```
			  
				- 同步熔断钩子，钩子订阅者按照顺序一个一个执行
				- 如果其中有一个钩子订阅者返回值非undefined时中断其它钩子执行

			- SyncWaterfallHook

			  ```
			  const { SyncWaterfallHook } = require('tapable');
			  
			  // 创建实列
			  const syncWaterfallHook = new SyncWaterfallHook(["name", "age"]);
			  
			  // 注册事件
			  syncWaterfallHook.tap("1", (name, age) => {
			    console.log("第一个函数事件名称", name, age);
			    return '1';
			  });
			  
			  syncWaterfallHook.tap("2", (data) => {
			    console.log("第二个函数事件名称", data);
			    return '2';
			  });
			  
			  syncWaterfallHook.tap("3", (data) => {
			    console.log("第三个函数事件名称", data);
			    return '3';
			  });
			  
			  // 触发事件，让监听函数执行
			  const res = syncWaterfallHook.call("SyncWaterfallHook", 18);
			  
			  console.log(res);
			  ```
			  输出：
			  ```
			  第一个函数事件名称 SyncWaterfallHook 18
			  第二个函数事件名称 1
			  第三个函数事件名称 2
			  3
			  ```
			  将上一个事件的返回值当做下一个的参数，如果上一个不存在，则向上取一个，如果上面也没有返回值则输出触发的第一个参数，如下去掉1、2的return 后输出内容：
			  ```
			  第一个函数事件名称 SyncWaterfallHook 18
			  第二个函数事件名称 SyncWaterfallHook
			  第三个函数事件名称 SyncWaterfallHook
			  3
			  ```
			  
				- 同步瀑布钩子，按顺序执行钩子
				- 前一个钩子的返回值作为下一个钩子的入参

			- SyncLoopHook

			  ```
			  const { SyncLoopHook } = require('tapable');
			  
			  // 创建实列
			  const syncLoopHook = new SyncLoopHook(["name", "age"]);
			  
			  // 定义辅助变量
			  let total1 = 0;
			  let total2 = 0;
			  
			  // 注册事件
			  syncLoopHook.tap("1", (name, age) => {
			    console.log("1", name, age, total1);
			    return total1++ < 2 ? true : undefined;
			  });
			  
			  syncLoopHook.tap("2", (name, age) => {
			    console.log("2", name, age, total2);
			    return total2++ < 2 ? true : undefined;
			  });
			  
			  syncLoopHook.tap("3", (name, age) => {
			    console.log("3", name, age);
			  });
			  
			  // 触发事件，让监听函数执行
			  syncLoopHook.call("SyncLoopHook", 18);
			  ```
			  输出：
			  ```
			  1 SyncLoopHook 18 0
			  1 SyncLoopHook 18 1
			  1 SyncLoopHook 18 2 -- 第一个事件循环执行，此时total1=3，返回值为undefined，事件向下执行
			  2 SyncLoopHook 18 0 -- 第二个事件执行，此时total2=1，返回值为undefined，事件从头开始执行
			  1 SyncLoopHook 18 3 -- 第二个事件返回值为undefined，事件从头开始执行，
			                          此时total1=4，返回值为undefined，事件向下执行
			  2 SyncLoopHook 18 1
			  1 SyncLoopHook 18 4
			  2 SyncLoopHook 18 2
			  3 SyncLoopHook 18
			  ```
			  
				- 同步循环钩子
				- 注册的事件处理函数返回 true 表示继续循环此事件处理函数，返回 undefined 表示结束该循环处理函数，继续执行下一个处理函数

		- 异步

			- 并行钩子

				- AsyncParallelHook

				  ```
				  const { AsyncParallelHook } = require('tapable');
				  
				  // 创建实列
				  const asyncParallelHook = new AsyncParallelHook(["name", "age"]);
				  
				  // 注册事件
				  asyncParallelHook.tapAsync("1", (name, age, callback) => {
				    setTimeout(() => {
				      console.log("1", name, age, new Date());
				      callback();
				    }, 1000);
				  });
				  
				  asyncParallelHook.tapAsync("2", (name, age, callback) => {
				    setTimeout(() => {
				      console.log("2", name, age, new Date());
				      callback();
				    }, 2000);
				  });
				  
				  asyncParallelHook.tapAsync("3", (name, age, callback) => {
				    setTimeout(() => {
				      console.log("3", name, age, new Date());
				      callback();
				    }, 3000);
				  });
				  
				  // 触发事件，让监听函数执行
				  asyncParallelHook.callAsync("AsyncParallelHook", 18, () => {
				    console.log('done');
				  });
				  ```
				  输出：
				  ```
				  1 AsyncParallelHook 18 2020-08-07T11:31:47.948Z
				  2 AsyncParallelHook 18 2020-08-07T11:31:48.986Z
				  3 AsyncParallelHook 18 2020-08-07T11:31:49.949Z
				  done
				  ```
				  从输出内容中，我们可以看出事件函数总共花费3秒执行完成。
				  而我们回调函数中最长也是延迟了3秒，说明每一个回调函数执行是同步执行的。
				  关于上面callback函数的说明：如果注册事件中没有调用callback则在callAsync中最后一个参数回调函数将不会执行。
				  
					- 异步并行钩子

				- AsyncParallelBailHook

					- 异步并行熔断钩子
					- 并行执行所有事件回调

			- 串行钩子

				- AsyncSeriesHook

				  ```
				  const { AsyncSeriesHook } = require('tapable');
				  
				  // 创建实列
				  const asyncSeriesHook = new AsyncSeriesHook(["name", "age"]);
				  
				  // 注册事件
				  asyncSeriesHook.tapAsync("1", (name, age, callback) => {
				    setTimeout(() => {
				      console.log("1", name, age, new Date());
				      callback();
				    }, 1000);
				  });
				  
				  asyncSeriesHook.tapAsync("2", (name, age, callback) => {
				    setTimeout(() => {
				      console.log("2", name, age, new Date());
				      callback();
				    }, 2000);
				  });
				  
				  asyncSeriesHook.tapAsync("3", (name, age, callback) => {
				    setTimeout(() => {
				      console.log("3", name, age, new Date());
				      callback();
				    }, 3000);
				  });
				  
				  // 触发事件，让监听函数执行
				  asyncSeriesHook.callAsync("AsyncSeriesHook", 18, () => {
				    console.log('done');
				  });
				  ```
				  输出：
				  ```
				  1 AsyncSeriesHook 18 2020-08-07T11:55:21.324Z
				  2 AsyncSeriesHook 18 2020-08-07T11:55:23.335Z
				  判断是否启动了watch3 AsyncSeriesHook 18 2020-08-07T11:55:26.341Z
				  done
				  ```
				  上面第一个注册函数的输出与第二个输出相差了2秒，第二个与第三个相差了3秒，三个注册函数总共执行了6秒。说明后一个注册事件的回调是在前一个执行完才开始执行的，如果某一个注册函数没有执行callback则后面的注册事件将不会执行。
				  
					- 异步串行钩子

				- AsyncSeriesBailHook

					- 异步串行熔断钩子
					- 异步执行回调
					- 如果有一个回调的返回值（callback、promise也一样）不为 undefined， 那么 callAsync 调用的回调中会优先拥有该回调返回值
					- 返回值方式可以是： return result、callback（null， result）、return Promise.reslove(result)中的一种

				- AsyncSeriesWaterfallHook

					- 异步串行瀑布钩子

				- AsyncSeriesLoopHook

					- 异步串行循环钩子

	- 钩子事件的订阅、发布

		- 同步钩子通过tap进行钩子事件的订阅，通过call进行事件的发布
		- 异步钩子的订阅： tapAsync/callAsync、tapPromise/promise

		  ```
		  const { AsyncParallelHook } = require('tapable');
		  
		  // 创建实列
		  const asyncParallelHook = new AsyncParallelHook(["name", "age"]);
		  
		  // 注册事件
		  asyncParallelHook.tapPromise("1", (name, age) => {
		    return new Promise((resolve, reject) => {
		      setTimeout(() => {
		        console.log("1", name, age, new Date());
		      }, 1000);
		    });
		  });
		  
		  asyncParallelHook.tapPromise("2", (name, age) => {
		    return new Promise((resolve, reject) => {
		      setTimeout(() => {
		        console.log("2", name, age, new Date());
		      }, 2000);
		    });
		  });
		  
		  asyncParallelHook.tapPromise("3", (name, age) => {
		    return new Promise((resolve, reject) => {
		      setTimeout(() => {
		        console.log("3", name, age, new Date());
		      }, 3000);
		    });
		  });
		  
		  // 触发事件，让监听函数执行
		  asyncParallelHook.promise("AsyncParallelHook", 18);
		  ```
		  tapAsync/callAsync：通过callback使事件函数向下一个事件函数执行
		  tapPromise/promise：通过返回一个Promise对象告诉下一个事件函数执行
		  
- loader和plugin的区别

	- loader本质是一个函数，将函数中接收的参数进行转换，并返回转换后的结果。通过module.rules进行配置
	- plugin是一个基于事件流框架 - Tapable，编写的插件，通过其可扩展webpack的功能，webpack在运行编译过程中会广播出各种事件，plugin可以监听这些事件，从而在合适时机改下输出结果；

- 代码分割和公共逻辑提取

	- 概念

		- module

			- 任何可以被导入导出的文件都是一个模块

		- chunk

			- webpack拆分出来的

				- 每个入口文件都是一个chunk
				- 通过 import、require 引入的代码 - 异步
				- 通过 splitChunks 拆分出来

		- bundle

			- webpack打包出来的文件，即对chunk编译压缩打包等处理后的产出。

	- 配置

	  //webpack.config.js
	  
	  optimization: {
	      splitChunks: {
	          cacheGroups: {
	              default: {
	                  name: 'common',
	                  chunks: 'initial'
	              }
	          }
	      }
	  }
	  
	  
		- cacheGroups

			- 配置代码拆分规则
			- 每个属性对应一个拆分规则

		- 缓存组属性

			- name

				- 提取出公共内容的文件名，可省略

			- chunks

				- 那些chunk参与拆分
				- all

					- 所有类型

				- async

					- 异步加载

				- initial

					- 初始化就能够获取到的模块

				- 函数

			- minChunks

				- 控制抽取的模块被entry最小引用次数，默认为1

			- priority 

				- 符合多个缓存组时，将选取优先级最高的规则

		- minSize

			- 提取出来的模块生成的文件最小大小限制，如果未达到将不会进行提取

		- test

		  //webpack.config.js
		  
		  optimization: {
		      splitChunks: {
		      minSize: 30,  //提取出的chunk的最小大小
		          cacheGroups: {
		              default: {
		              },
		              vendors: {  //拆分第三方库（通过npm|yarn安装的库）
		                test: /[\\/]node_modules[\\/]/,
		                  name: 'vendor',
		                  chunks: 'initial',
		                  priority: -10
		              }
		          }
		      }
		  }
		  
		  
			- 缓存中选择的模块，可以是一个正则也可以是一个函数

	- 原理

		- 准备阶段

			- 1. 首先给每个chunk进行编号，结果存储在 indexMap 结构中

			  /**
			  					 * 1. 给每个chunk一个编号
			  					 * 2. 分析每个module被哪些chunk引用，如果没有被其他chunk引用，
			  					 * 3. 将步骤2中的结果根据被chunk引用的次数进行归类，key为次数，value为chunk数组
			  					 * pageA - 1
			  					 * pageB - 2
			  					 * pageC - 3
			  					 */
			  const indexMap = new Map();
			  for (const chunk of chunks) {
			      indexMap.set(chunk, index++);
			  }
			  
			- 2. 遍历每个module，查找每个module被哪些chunk引用，保存在 chunkSetsInGraph

			  /**
			   * 优化的核心就是提取公共的module，所以要为每个module和包含该module的chunks生成一个key值，
			   * 每个module对应一个key，也对应所有包含该module的chunks集合（chunksSet），
			   * 这样我们就知道每个module在哪些chunk中重复了，这对优化起了关键作用。
			   * 这里将该key值和这些chunks建立映射关系，存在chunkSetsInGraph中，便于之后通过key值取出这些chunksSet，进行优化。
			   */
			  const chunkSetsInGraph = new Map();
			  // 遍历每个module，查找每个module被哪些chunk引用，保存在 chunkSetsInGraph
			  /**
			   * compilation.modules = [pageA, pageB, pageC, utility1, utility2, utility3]
			   * [
			   *  [1 - [pageA]], // utility1 被一个chunk引用了
			   *  [1,2,3 - [pageA, pageB, pageC]], // utility2 被三个chunk引用了
			   *  [2 - [pageB]],
			   *  [2,3 - [pageB,pageC]], // utility3 被两个chunk引用了
			   *  [3 - [pageC]]
			   * ]
			   * key: module在哪些chunks中
			   * value: 包含哪些chunk
			   */
			  for (const module of compilation.modules) {
			      // module.chunksIterable 存储该module被那些chunk使用
			      // pageA - chunkA
			      // utility2 -- chunkA, chunkB, chunkC
			      // utility3 -- chunkB, chunkC
			      const chunksKey = getKey(module.chunksIterable);
			      if (!chunkSetsInGraph.has(chunksKey)) {
			          chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));
			      }
			  }
			  
				- 为每个module和包含该module的chunks生成一个key值，每个module对应一个key，也对应所有包含该module的chunks集合（chunksSet）
				- value为module被依赖的chunk对象
				- 说明

					-     utility1 被 pageA引用，则key为“1”，value为PageA组成的set集合。
    utility2 被 pageA, pageB, pageC 引用，则key为“1,2,3”， value为 pageA, pageB, pageC 组成的set集合。
    从 chunkSetsInGraph集合的value我们可以了解到，模块被chunk依赖的情况；
    [
        [1 - [pageA]],
        [1,2,3 - [pageA, pageB, pageC]], // 模块中存在被3个chunk依赖的module
        [2 - [pageB]],
        [2,3 - [pageB,pageC]], // 模块中存在被2个chunk依赖的module
        [3 - [pageC]]
    ]

				- 结果

					- 知道每个module在哪些chunk中重复

			- 3. 根据步骤2中的结果，再次根据module被chunk引用的数量进行归类，结果保存在chunkSetsByCount

			  // 将这些组块按计数分组
			  /*
			      chunkSetsInGraph存储了所有module被chunk使用的情况，需要对使用次数进行进一步归类，将结果存储在chunkSetsByCount集合中。
			      下面可以根据minChunks配置快速的找到对应的chunkSet的集合。
			      一个module对应一个chunksSet，一个count对应多个chunksSet，也就对应多个module
			      chunkSetsByCount:
			          [
			              [1, [[pageA], [pageB]， [pageC]]],
			              [2, [[pageB,pageC]]],
			              [3, [[pageA, pageB, pageC]]]
			          ]
			   */
			  const chunkSetsByCount = new Map();
			  
			  for (const chunksSet of chunkSetsInGraph.values()) {
			      const count = chunksSet.size;
			      let array = chunkSetsByCount.get(count);
			      if (array === undefined) {
			          array = [];
			          chunkSetsByCount.set(count, array);
			      }
			      array.push(chunksSet);
			  }
			  
				- chunkSetsInGraph存储了所有module被chunk使用的情况，需要对使用次数进行进一步归类
				- 一个module对应一个chunksSet，一个count对应多个chunksSet，也就对应多个module

		- 模块分组

		  
		  // Walk through all modules
		  // 遍历所有模块
		  for (const module of compilation.modules) {
		      // Get cache group
		      // 获取缓存组
		      let cacheGroups = this.options.getCacheGroups(module);
		      if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {
		          continue;
		      }
		  
		      // Prepare some values
		      // module 被那些 chunk 使用，返回chunk的组成的ID
		      const chunksKey = getKey(module.chunksIterable);
		      let combs = combinationsCache.get(chunksKey);
		      if (combs === undefined) {
		          // 获得可能满足minChunks条件chunks集合，用于后续和minChunks条件比对
		          // 取出模块被哪些 chunk 依赖了。
		          // utility2 被 pageA, pageB, pageC 三个chunk依赖，返回有其set组成的 数组
		          combs = getCombinations(chunksKey);
		          combinationsCache.set(chunksKey, combs);
		      }
		  
		      let cacheGroupIndex = 0;
		      for (const cacheGroupSource of cacheGroups) {
		          const minSize =
		              cacheGroupSource.minSize !== undefined
		                  ? cacheGroupSource.minSize
		                  : cacheGroupSource.enforce
		                  ? 0
		                  : this.options.minSize;
		          const enforceSizeThreshold =
		              cacheGroupSource.enforceSizeThreshold !== undefined
		                  ? cacheGroupSource.enforceSizeThreshold
		                  : cacheGroupSource.enforce
		                  ? 0
		                  : this.options.enforceSizeThreshold;
		          const cacheGroup = {
		              key: cacheGroupSource.key,
		              priority: cacheGroupSource.priority || 0,
		              chunksFilter:
		                  cacheGroupSource.chunksFilter || this.options.chunksFilter,
		              minSize,
		              minSizeForMaxSize:
		                  cacheGroupSource.minSize !== undefined
		                      ? cacheGroupSource.minSize
		                      : this.options.minSize,
		              enforceSizeThreshold,
		              maxSize:
		                  cacheGroupSource.maxSize !== undefined
		                      ? cacheGroupSource.maxSize
		                      : cacheGroupSource.enforce
		                      ? 0
		                      : this.options.maxSize,
		              minChunks:
		                  cacheGroupSource.minChunks !== undefined
		                      ? cacheGroupSource.minChunks
		                      : cacheGroupSource.enforce
		                      ? 1
		                      : this.options.minChunks,
		              maxAsyncRequests:
		                  cacheGroupSource.maxAsyncRequests !== undefined
		                      ? cacheGroupSource.maxAsyncRequests
		                      : cacheGroupSource.enforce
		                      ? Infinity
		                      : this.options.maxAsyncRequests,
		              maxInitialRequests:
		                  cacheGroupSource.maxInitialRequests !== undefined
		                      ? cacheGroupSource.maxInitialRequests
		                      : cacheGroupSource.enforce
		                      ? Infinity
		                      : this.options.maxInitialRequests,
		              getName:
		                  cacheGroupSource.getName !== undefined
		                      ? cacheGroupSource.getName
		                      : this.options.getName,
		              filename:
		                  cacheGroupSource.filename !== undefined
		                      ? cacheGroupSource.filename
		                      : this.options.filename,
		              automaticNameDelimiter:
		                  cacheGroupSource.automaticNameDelimiter !== undefined
		                      ? cacheGroupSource.automaticNameDelimiter
		                      : this.options.automaticNameDelimiter,
		              reuseExistingChunk: cacheGroupSource.reuseExistingChunk,
		              _validateSize: minSize > 0,
		              _conditionalEnforce: enforceSizeThreshold > 0
		          };
		          // For all combination of chunk selection
		          // module： utility2 被 pageA, pageB, pageC 三个chunk依赖，返回有其set组成的 数组
		          /*
		              combs:
		                  [
		                      [chunkA, chunkB, chunkC],
		                      [chunkB, chunkC],
		                      [chunkA],
		                      [chunkB],
		                      [chunkC]
		                  ]
		           */
		          // 根据我们的cacheGroup配置，筛选出符合minChunks和chunks规则的chunk
		          for (const chunkCombination of combs) {
		              // Break if minimum number of chunks is not reached
		              // 如果不满足minChunks，就直接break，不建立这个缓存组，也就不会分割相应代码
		              if (chunkCombination.size < cacheGroup.minChunks) continue;
		              // Select chunks by configuration
		              // 解构赋值，获得符合chunksFilter（"initial" | "async" | "all"，其实就是chunks属性）条件的chunks
		              // key： 由那些 chunk 依赖所组成的字符串 - 1,2,3
		              // chunks：符合 chunksFilter 的chunk - [chunkA, chunkB, chunkC]
		              const {
		                  chunks: selectedChunks,
		                  key: selectedChunksKey
		              } = getSelectedChunks(
		                  chunkCombination,
		                  cacheGroup.chunksFilter
		              );
		  
		              // 将目前符合条件的modules、chunks和cacheGroup信息存到chunksInfoMap中
		              addModuleToChunksInfoMap(
		                  cacheGroup,
		                  cacheGroupIndex,
		                  selectedChunks, // 符合拆分条件的chunk集合 - [chunkA, chunkB, chunkC]
		                  selectedChunksKey, // 需要被拆分的chunk编号 - 1,2,3
		                  module // 需要被处理的module - utility2
		              );
		          }
		          cacheGroupIndex++;
		      }
		  }
		  
		  
		  
			- 1. 遍历所有模块，获取module从属的cacheGroup，遍历分组

			  for (const module of compilation.modules) {
			      // 通过getCacheGroups得到module从属的cacheGroup，一个module可能符合多个cacheGroup的条件
			      let cacheGroups = this.options.getCacheGroups(module);
			  
			      // 包含同一个module的chunk会对应唯一的key值，以便接下来获取要优化的chunks集合
			      // module.chunksIterable 包含module被哪些chunk依赖了，getKey会根据chunk生成的ID返回一个字符串
			      const chunksKey = getKey(module.chunksIterable);
			      let combs = combinationsCache.get(chunksKey);
			      if (combs === undefined) {
			          // 这是准备阶段定义的方法，获得可能满足minChunks条件chunks集合，用于后续和minChunks条件比对
			          // 取出模块被哪些 chunk 依赖了。
			          // utility2 被 pageA, pageB, pageC 三个chunk依赖，返回有其set组成的 数组
			          combs = getCombinations(chunksKey);
			          combinationsCache.set(chunksKey, combs);
			      }
			  
			      let cacheGroupIndex = 0;
			      for (const cacheGroupSource of cacheGroups) {
			          /**/
			      }
			  }
			  
			- 2. 根据我们的cacheGroup配置，筛选出符合minChunks和chunks规则的chunk

			  // 将什么类型的代码块用于分割，三选一： "initial"：入口代码块 | "all"：全部 | "async"：按需加载的代码块
			  static normalizeChunksFilter(chunks) {
			      if (chunks === "initial") {
			          return INITIAL_CHUNK_FILTER;
			      }
			      if (chunks === "async") {
			          return ASYNC_CHUNK_FILTER;
			      }
			      if (chunks === "all") {
			          return ALL_CHUNK_FILTER;
			      }
			      if (typeof chunks === "function") return chunks;
			  }
			  // chunkFilter = normalizeChunksFilter
			  const getSelectedChunks = (chunks, chunkFilter) => {
			      let entry = selectedChunksCacheByChunksSet.get(chunks);
			      if (entry === undefined) {
			          entry = new WeakMap();
			          selectedChunksCacheByChunksSet.set(chunks, entry);
			      }
			      /** @type {SelectedChunksResult} */
			      let entry2 = entry.get(chunkFilter);
			      if (entry2 === undefined) {
			          /** @type {Chunk[]} */
			          const selectedChunks = [];
			          for (const chunk of chunks) {
			              if (chunkFilter(chunk)) selectedChunks.push(chunk);
			          }
			          entry2 = {
			              chunks: selectedChunks,
			              key: getKey(selectedChunks)
			          };
			          entry.set(chunkFilter, entry2);
			      }
			      return entry2;
			  };
			  
			- 3.  将目前符合条件的modules、chunks和cacheGroup信息存到chunksInfoMap中

			  /**
			   * [
			   *  ['commons name:commons~pageA~pageB~pageC' - {chunks: [pageA,pageB,pageC], chunksKeys: [1,2,3], modules: [utility2]}],
			   *  ['commons name:commons~pageB~pageC' - {chunks: [pageB,pageC], chunksKeys: [2,3], modules: [utility2,utility3]}]
			   * ]
			   */
			  const chunksInfoMap = new Map();
			  const addModuleToChunksInfoMap = (
			      cacheGroup,
			      cacheGroupIndex,
			      selectedChunks, // 将被分离的chunk
			      selectedChunksKey,
			      module // 将被分割的module
			  ) => {
			  
			      // 提取chunk的名称
			      const name = cacheGroup.getName(
			          module,
			          selectedChunks,
			          cacheGroup.key
			      );
			  
			      /**
			       * 如果cachGroup有name，就用cacheGroup的key和name作为key，如果没有，就是用从cacheGroup和chunk生成的key值（selectedChunksKey）。
			       * 如果cachGroup有name，属于该cachGroup的module在这里的key值都是一样的，所以会合并到一个info中，最后打成一个包，
			       * 而如果cachGroup没有name，每个module会生成不同key，最后每个module都会单独打成一个包，
			       */
			      const key =
			          cacheGroup.key +
			          (name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);
			      let info = chunksInfoMap.get(key);
			      if (info === undefined) {
			          chunksInfoMap.set(
			              key,
			              (info = {
			                  modules: new SortableSet(undefined, sortByIdentifier),
			                  cacheGroup,
			                  cacheGroupIndex,
			                  name,
			                  size: 0,
			                  chunks: new Set(),
			                  reuseableChunks: new Set(),
			                  chunksKeys: new Set()
			              })
			          );
			      }
			      info.modules.add(module);
			      info.size += module.size();
			      if (!info.chunksKeys.has(selectedChunksKey)) {
			          info.chunksKeys.add(selectedChunksKey);
			          for (const chunk of selectedChunks) {
			              info.chunks.add(chunk);
			          }
			      }
			  };
			  
		- 排队检查

		  
		  // Filter items were size < minSize
		  // 再次过滤 - 将体积小于minSize的缓存组(这里对应chunsInfoItem)从chunksInfoMap中删除
		  for (const pair of chunksInfoMap) {
		      const info = pair[1];
		      if (
		          info.cacheGroup._validateSize &&
		          info.size < info.cacheGroup.minSize
		      ) {
		          chunksInfoMap.delete(pair[0]);
		      }
		  }
		  
		  /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */
		  const maxSizeQueueMap = new Map();
		  
		  while (chunksInfoMap.size > 0) {
		      // Find best matching entry
		      // 寻找最匹配的cacheGroup分组信息，优先进行分割，优先产生打包结果
		      let bestEntryKey;
		      let bestEntry;
		      /*
		          [
		              ['commons name:commons~pageA~pageB~pageC' - {chunks: [pageA,pageB,pageC], chunksKeys: [1,2,3], modules: [utility2]}],
		              ['commons name:commons~pageB~pageC' - {chunks: [pageB,pageC], chunksKeys: [2,3], modules: [utility2,utility3]}]
		          ]
		       */
		      for (const pair of chunksInfoMap) {
		          const key = pair[0];
		          const info = pair[1];
		          if (bestEntry === undefined) {
		              bestEntry = info;
		              bestEntryKey = key;
		          } else if (compareEntries(bestEntry, info) < 0) {
		              bestEntry = info;
		              bestEntryKey = key;
		          }
		      }
		  
		      const item = bestEntry;
		      chunksInfoMap.delete(bestEntryKey);
		  
		      let chunkName = item.name;
		      // Variable for the new chunk (lazy created)
		      /** @type {Chunk} */
		      let newChunk;
		      // When no chunk name, check if we can reuse a chunk instead of creating a new one
		      // 如果没有chunk名称，请检查是否可以重用chunk而不是创建一个新chunk
		      let isReused = false;
		      if (item.cacheGroup.reuseExistingChunk) {}
		      // Check if maxRequests condition can be fulfilled
		  
		      const selectedChunks = Array.from(item.chunks).filter(chunk => {
		          // skip if we address ourself
		          return (
		              (!chunkName || chunk.name !== chunkName) && chunk !== newChunk
		          );
		      });
		  
		      const enforced =
		          item.cacheGroup._conditionalEnforce &&
		          item.size >= item.cacheGroup.enforceSizeThreshold;
		  
		      // Skip when no chunk selected
		      if (selectedChunks.length === 0) continue;
		  
		      const usedChunks = new Set(selectedChunks);
		  
		      // Check if maxRequests condition can be fulfilled
		      // 检测缓存组中的代码块是否满足maxInitialRequests和maxAsyncRequests条件，如果它们都是无穷大，就没必要检测了
		      if (
		          !enforced &&
		          (Number.isFinite(item.cacheGroup.maxInitialRequests) ||
		              Number.isFinite(item.cacheGroup.maxAsyncRequests))
		      ) {
		          for (const chunk of usedChunks) {
		              // respect max requests
		              // 如果chunk只是初始代码块，只需判断 maxInitialRequests 条件是否满足；
		              // 如果chunk可以作为初始代码块，就取两者最小值；
		              // 如果chunk不是初始代码块，只需判断 maxAsyncRequests 条件是否满足；
		              const maxRequests = chunk.isOnlyInitial()
		                  ? item.cacheGroup.maxInitialRequests
		                  : chunk.canBeInitial()
		                  ? Math.min(
		                          item.cacheGroup.maxInitialRequests,
		                          item.cacheGroup.maxAsyncRequests
		                    )
		                  : item.cacheGroup.maxAsyncRequests;
		  
		              // 如果不满足最大请求数的条件，则从validChunks中去除
		              if (
		                  isFinite(maxRequests) &&
		                  getRequests(chunk) >= maxRequests
		              ) {
		                  usedChunks.delete(chunk);
		              }
		          }
		      }
		  
		      outer: for (const chunk of usedChunks) {
		          for (const module of item.modules) {
		              if (chunk.containsModule(module)) continue outer;
		          }
		          usedChunks.delete(chunk);
		      }
		  
		      // Were some (invalid) chunks removed from usedChunks?
		      // => readd all modules to the queue, as things could have been changed
		      if (usedChunks.size < selectedChunks.length) {
		          if (usedChunks.size >= item.cacheGroup.minChunks) {
		              const chunksArr = Array.from(usedChunks);
		              for (const module of item.modules) {
		                  addModuleToChunksInfoMap(
		                      item.cacheGroup,
		                      item.cacheGroupIndex,
		                      chunksArr,
		                      getKey(usedChunks),
		                      module
		                  );
		              }
		          }
		          continue;
		      }
		  
		      // Create the new chunk if not reusing one
		      // 如果不重用一个，则创建新的chunk，加入compilation的chunkGraph
		      if (!isReused) {
		          newChunk = compilation.addChunk(chunkName);
		      }
		      // Walk through all chunks
		      for (const chunk of usedChunks) {
		          // Add graph connections for splitted chunk
		          chunk.split(newChunk);
		      }
		  
		      // Add a note to the chunk
		      newChunk.chunkReason = isReused
		          ? "reused as split chunk"
		          : "split chunk";
		      if (item.cacheGroup.key) {
		          newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;
		      }
		      if (chunkName) {
		          newChunk.chunkReason += ` (name: ${chunkName})`;
		          // If the chosen name is already an entry point we remove the entry point
		          // 如果所选名称已经是入口点，我们将删除该入口点
		          const entrypoint = compilation.entrypoints.get(chunkName);
		          if (entrypoint) {
		              compilation.entrypoints.delete(chunkName);
		              entrypoint.remove();
		              newChunk.entryModule = undefined;
		          }
		      }
		      if (item.cacheGroup.filename) {
		          if (!newChunk.isOnlyInitial()) {
		              throw new Error(
		                  "SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. " +
		                      "The runtime can only handle loading of chunks which match the chunkFilename schema. " +
		                      "Using a custom filename would fail at runtime. " +
		                      `(cache group: ${item.cacheGroup.key})`
		              );
		          }
		          newChunk.filenameTemplate = item.cacheGroup.filename;
		      }
		      if (!isReused) {
		          // Add all modules to the new chunk
		          // 增加所有module到新的chunk中
		          for (const module of item.modules) {
		              if (typeof module.chunkCondition === "function") {
		                  if (!module.chunkCondition(newChunk)) continue;
		              }
		              // Add module to new chunk
		              // 增加module到新的chunk中
		              GraphHelpers.connectChunkAndModule(newChunk, module);
		              // Remove module from used chunks
		              // 从旧的chunk中移除module
		              // 如果缓存组中所有module都被复用了，则从usedChunks中将这些module全部删除，避免冗余
		              for (const chunk of usedChunks) {
		                  chunk.removeModule(module);
		                  module.rewriteChunkInReasons(chunk, [newChunk]);
		              }
		          }
		      } else {
		          // Remove all modules from used chunks
		          for (const module of item.modules) {
		              for (const chunk of usedChunks) {
		                  chunk.removeModule(module);
		                  module.rewriteChunkInReasons(chunk, [newChunk]);
		              }
		          }
		      }
		  
		      if (item.cacheGroup.maxSize > 0) {
		          const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);
		          maxSizeQueueMap.set(newChunk, {
		              minSize: Math.max(
		                  oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,
		                  item.cacheGroup.minSizeForMaxSize
		              ),
		              maxSize: Math.min(
		                  oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,
		                  item.cacheGroup.maxSize
		              ),
		              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,
		              keys: oldMaxSizeSettings
		                  ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)
		                  : [item.cacheGroup.key]
		          });
		      }
		  
		      // remove all modules from other entries and update size
		      // 从其他条目中删除所有模块并更新大小
		      for (const [key, info] of chunksInfoMap) {
		          if (isOverlap(info.chunks, usedChunks)) {
		              // update modules and total size
		              // may remove it from the map when < minSize
		              const oldSize = info.modules.size;
		              for (const module of item.modules) {
		                  info.modules.delete(module);
		              }
		              if (info.modules.size !== oldSize) {
		                  if (info.modules.size === 0) {
		                      chunksInfoMap.delete(key);
		                      continue;
		                  }
		                  info.size = getModulesSize(info.modules);
		                  if (
		                      info.cacheGroup._validateSize &&
		                      info.size < info.cacheGroup.minSize
		                  ) {
		                      chunksInfoMap.delete(key);
		                  }
		                  if (info.modules.size === 0) {
		                      chunksInfoMap.delete(key);
		                  }
		              }
		          }
		      }
		  }
		  
		  const incorrectMinMaxSizeSet = new Set();
		  
		  // Make sure that maxSize is fulfilled
		  // 确保满足maxSize
		  for (const chunk of compilation.chunks.slice()) {
		      const { minSize, maxSize, automaticNameDelimiter, keys } =
		          maxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;
		      if (!maxSize) continue;
		      if (minSize > maxSize) {
		          const warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;
		          if (!incorrectMinMaxSizeSet.has(warningKey)) {
		              incorrectMinMaxSizeSet.add(warningKey);
		              compilation.warnings.push(
		                  new MinMaxSizeWarning(keys, minSize, maxSize)
		              );
		          }
		      }
		      const results = deterministicGroupingForModules({
		          maxSize: Math.max(minSize, maxSize),
		          minSize,
		          items: chunk.modulesIterable,
		          getKey(module) {
		              const ident = contextify(
		                  compilation.options.context,
		                  module.identifier()
		              );
		              const name = module.nameForCondition
		                  ? contextify(
		                          compilation.options.context,
		                          module.nameForCondition()
		                    )
		                  : ident.replace(/^.*!|\?[^?!]*$/g, "");
		              const fullKey =
		                  name + automaticNameDelimiter + hashFilename(ident);
		              return fullKey.replace(/[\\/?]/g, "_");
		          },
		          getSize(module) {
		              return module.size();
		          }
		      });
		      results.sort((a, b) => {
		          if (a.key < b.key) return -1;
		          if (a.key > b.key) return 1;
		          return 0;
		      });
		      for (let i = 0; i < results.length; i++) {
		          const group = results[i];
		          const key = this.options.hidePathInfo
		              ? hashFilename(group.key)
		              : group.key;
		          let name = chunk.name
		              ? chunk.name + automaticNameDelimiter + key
		              : null;
		          if (name && name.length > 100) {
		              name =
		                  name.slice(0, 100) +
		                  automaticNameDelimiter +
		                  hashFilename(name);
		          }
		          let newPart;
		          if (i !== results.length - 1) {
		              newPart = compilation.addChunk(name);
		              chunk.split(newPart);
		              newPart.chunkReason = chunk.chunkReason;
		              // Add all modules to the new chunk
		              for (const module of group.items) {
		                  if (typeof module.chunkCondition === "function") {
		                      if (!module.chunkCondition(newPart)) continue;
		                  }
		                  // Add module to new chunk
		                  GraphHelpers.connectChunkAndModule(newPart, module);
		                  // Remove module from used chunks
		                  chunk.removeModule(module);
		                  module.rewriteChunkInReasons(chunk, [newPart]);
		              }
		          } else {
		              // change the chunk to be a part
		              newPart = chunk;
		              chunk.name = name;
		          }
		      }
		  }
		  
			- 子主题 4
			- 1. 将体积小于minSize的缓存组(这里对应chunsInfoItem)从chunksInfoMap中删除

			  for (const pair of chunksInfoMap) {
			      const info = pair[1];
			      if (
			          info.cacheGroup._validateSize &&
			          info.size < info.cacheGroup.minSize
			      ) {
			          chunksInfoMap.delete(pair[0]);
			      }
			  }
			  
			- 2. 根据比较规则，寻找最匹配的cacheGroup分组信息，优先进行分割，优先产生打包结果

			  for (const pair of chunksInfoMap) {
			      const key = pair[0];
			      const info = pair[1];
			      if (bestEntry === undefined) {
			          bestEntry = info;
			          bestEntryKey = key;
			      } else if (compareEntries(bestEntry, info) < 0) {
			          bestEntry = info;
			          bestEntryKey = key;
			      }
			  }
			  // 比较规则
			  const compareEntries = (a, b) => {
			      // 1. by priority （缓存组优先级）
			      const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;
			      if (diffPriority) return diffPriority;
			      // 2. by number of chunks （公共module被哪些chunk共用）
			      const diffCount = a.chunks.size - b.chunks.size;
			      if (diffCount) return diffCount;
			      // 3. by size reduction (比较chunk内容大小)
			      const aSizeReduce = a.size * (a.chunks.size - 1);
			      const bSizeReduce = b.size * (b.chunks.size - 1);
			      const diffSizeReduce = aSizeReduce - bSizeReduce;
			      if (diffSizeReduce) return diffSizeReduce;
			      // 4. by cache group index （比较缓存组索引）
			      const indexDiff = a.cacheGroupIndex - b.cacheGroupIndex;
			      if (indexDiff) return indexDiff;
			      // 5. by number of modules (to be able to compare by identifier) 这里的 modules 指的是被chunk公共使用的module
			      const modulesA = a.modules;
			      const modulesB = b.modules;
			      // 比较chunk中module数量
			      const diff = modulesA.size - modulesB.size;
			      if (diff) return diff;
			      // 6. by module identifiers
			      modulesA.sort();
			      modulesB.sort();
			      const aI = modulesA[Symbol.iterator]();
			      const bI = modulesB[Symbol.iterator]();
			      // eslint-disable-next-line no-constant-condition
			      while (true) {
			          const aItem = aI.next();
			          const bItem = bI.next();
			          if (aItem.done) return 0;
			          const aModuleIdentifier = aItem.value.identifier();
			          const bModuleIdentifier = bItem.value.identifier();
			          if (aModuleIdentifier > bModuleIdentifier) return -1;
			          if (aModuleIdentifier < bModuleIdentifier) return 1;
			      }
			  };
			  
				- a. 根据缓存组优先级进行比较；
				-         b. 优先级相同则比较被依赖chunk的数量；
				-         c. 比较chunk内容大小；
				-         d. 比较缓存组索引;
				-         e. 比较chunk中module数量；
				-         f. 比较chunk中module的标识符；

			- 3. 找到最佳缓存组后把缓存组中的模块打包成新的代码块，并从之前的chunk中移除

			  // 增加所有module到新的chunk中
			  for (const module of item.modules) {
			      if (typeof module.chunkCondition === "function") {
			          if (!module.chunkCondition(newChunk)) continue;
			      }
			      // Add module to new chunk
			      // 增加module到新的chunk中
			      GraphHelpers.connectChunkAndModule(newChunk, module);
			      // Remove module from used chunks
			      // 从旧的chunk中移除module
			      // 如果缓存组中所有module都被复用了，则从usedChunks中将这些module全部删除，避免冗余
			      for (const chunk of usedChunks) {
			          chunk.removeModule(module);
			          module.rewriteChunkInReasons(chunk, [newChunk]);
			      }
			  }
			  
				- 将module加入到新的chunk中
				- 将模块从旧的chunk中移除

			- 4. 一些其他条件的判断

- 简单实现

	- 编写读取入口文件

	  ```
	  const fs = require('fs');
	  const getModuleInfo = (file) => {
	    const content = fs.readFileSync(file, 'utf-8');
	    console.log(content);
	  }
	  
	  getModuleInfo('./src/main.js');
	  ```
	  
	- 使用依赖包@babel/parser进行代码分析

	  ```
	  const fs = require('fs');
	  // +
	  const parser = require('@babel/parser');
	  const getModuleInfo = (file) => {
	    const content = fs.readFileSync(file, 'utf-8');
	    // +
	    const ast = parser.parse(content, {
	      sourceType: 'module'
	    });
	    console.log(ast.program.body);
	  }
	  
	  getModuleInfo('./src/main.js');
	  ```
	  
	- 使用依赖包@babel/traverse 收集依赖

	  ```
	  const fs = require('fs');
	  const parser = require('@babel/parser');
	  // +
	  const path = require('path');
	  const traverse = require('@babel/traverse').default;
	  const getModuleInfo = (file) => {
	    const content = fs.readFileSync(file, 'utf-8');
	    const ast = parser.parse(content, {
	      sourceType: 'module'
	    });
	    // +
	    const deps = {};
	    traverse(ast, {
	      // 对type类型为ImportDeclaration的节点的处理
	      ImportDeclaration({node}) {
	        const dirname = path.dirname(file);
	        const abspath = './' + path.join(dirname,node.source.value);
	        deps[node.source.value] = abspath;
	      }
	    });
	    console.log(deps);
	  }
	  
	  getModuleInfo('./src/main.js');
	  ```
	  
	- 使用依赖包 @babel/core @babel/preset-env 的 transformFromAst 方法，将ES6代码装换成ES5

	  ```
	  const fs = require('fs');
	  const parser = require('@babel/parser');
	  const path = require('path');
	  const traverse = require('@babel/traverse').default;
	  // +
	  const babel = require('@babel/core');
	  const getModuleInfo = (file) => {
	    // 1. 
	    const content = fs.readFileSync(file, 'utf-8');
	    // 2. 
	    const ast = parser.parse(content, {
	      sourceType: 'module'
	    });
	    // 3. 
	    const deps = {};
	    traverse(ast, {
	      // 对type类型为ImportDeclaration的节点的处理
	      ImportDeclaration({node}) {
	        const dirname = path.dirname(file);
	        const abspath = './' + path.join(dirname,node.source.value);
	        deps[node.source.value] = abspath;
	      }
	    });
	    // +
	    const {code} = babel.transformFromAst(ast, null, {
	      presets: ['@babel/preset-env']
	    });
	    console.log(code);
	  
	    return {file, deps, code};
	  }
	  
	  getModuleInfo('./src/main.js');
	  ```
	  
	- 使用递归获取所有文件代码

	  ```
	  const parseModules = (file) => {
	    const entry = getModuleInfo(file);
	    const temp = [entry];
	    for (const i = 0; i < temp.length; i++) {
	      const deps = temp[i].deps;
	      if (deps) {
	        for (const key in deps) {
	          if (deps.hasOwnProperty(key)) {
	            temp.push(getModuleInfo(deps[key]));
	          }
	        }
	      }
	    }
	  
	    const depsGraph = {};
	    temp.forEach(moduleInfo => {
	      depsGraph[moduleInfo.file] = {
	        deps: moduleInfo.deps,
	        code: moduleInfo.code
	      }
	    })
	    console.log(depsGraph);
	  
	    return depsGraph;
	  }
	  ```
	  
	- 定义浏览器能够识别的require方法

	  ```
	  const bundle = (file) => {
	    const depsGraph = JSON.stringify(parseModules(file));
	    return `
	      (function(graph) {
	        function require(file) {
	          // 绝对路径，需要转化成绝对路径
	          function absRequire(relPath) {
	            return require(graph[file].deps[relPath]);
	          }
	          (function (require, code) {
	            // 执行主模块的code
	            eval(code);
	          })(absRequire, graph[file].code);
	        }
	        // 主模块路径传入require
	        require(file);
	      })(depsGraph);
	    `;
	  };
	  ```
	  
	- 处理 exports

	  ```
	  const bundle = (file) => {
	    const depsGraph = JSON.stringify(parseModules(file));
	    return `
	      (function(graph) {
	        function require(file) {
	          // 绝对路径，需要转化成绝对路径
	          function absRequire(relPath) {
	            return require(graph[file].deps[relPath]);
	          }
	          let exports = {};
	          (function (require, code) {
	            // 执行主模块的code
	            eval(code);
	          })(absRequire, graph[file].code);
	  
	          return exports;
	        }
	        // 主模块路径传入require
	        require(file);
	      })(depsGraph);
	    `;
	  };
	  ```
	  
### rollup

## node

### 生命周期

- 定时器（Timer）阶段

	- setTimeout, setInterval
	- 事件循环进入计时器阶段时会检查在`Timers Queue`中是否有需要执行的任务，计时器脚本以升序存储在堆内存中
	- 首先获取到一个执行计数器，计算下是否 now - registeredTime >= delta？如果是，他会执这个行计时器的回调并且检查下一个计时器。直到找到一个还没到约定时间的计时器， 它会停止检查其他的定时器（因为定时器都以升序排好了）并且移到下一个阶段了
	- 如果达到系统依赖最大限制数量，即使有未执行的计时器，它也会移到下一阶段。

- 即将发生的（Pending） i/o 回调阶段

	- 错误处理的回调
	- 检查 `IO Callbacks Queue`中是否有来自于之前的即将发生的任务的回调
	- 队列为空，或者达到系统的最大限制将进入下一个阶段

- Idle（空闲）, Prepare 阶段
- 轮询（Poll）阶段

	- 接受新传入的连接（新的 Socket 建立等）和数据（文件读取等）
	- 轮询阶段会分成两个部分执行

		- 队列不为空

			- 在 watcher_queue 中执行脚本，包含文件读响应，新的 socket 或者 http 连接请求，直到时间耗尽或者像其他阶段那样达到系统依赖上限

		- 队列为空

			- 如果之前设置过setImmediate函数，直接进入下一个check阶段
			- 如果之前没有设置过setImmediate函数，在当前poll阶段等待
			- 直到轮询队列添加回调函数，就去第一个情况执行，如果定时器到点了，也会去下一个阶段

- 检查（Check）阶段

	- setImmediate
	- 队列为空或者达到依赖系统的最大限制将进入下一个阶段

- 关闭（Close）回调

	- 回调的关闭(socket.on(‘close’, ()=>{}))
	- 事件循环执行完这个阶段的队列中的回调后，它会检查循环（loop）是否还活着，如果没有，退出

## 工程化

### ast

### babel

- babel编译原理

	- babylon 将 ES6/ES7 代码解析成 AST
	- babel-traverse 对 AST 进行遍历转译，得到新的 AST
	- 新 AST 通过 babel-generator 转换成 ES5

### 微前端

- qiankun

### 代码格式化

### npm

- npm install安装机制

	- 发出npm install 命令
	- 查询node_modules目录中是否已经安装了指定模块

		- 如果已经存在，则不会安装
		- 如果不存在

			- npm向registry指定的地址下载安装包
			- 接着存放到根目录下的.npm目录中
			- 解压压缩包到当前项目的node_modules

- npm install 的实现原理

	- 如果项目中预定义了 preinstall 钩子方法，则执行
	- 确定首层依赖，即dependencies和devDependencies指定的模块

		- 所有依赖会构成一颗树，树的根既是当前项目
		- 每个首层依赖都是根的一颗子树
		- npm会开启多个进程从每个首层依赖模块开始逐步寻找更深层次的节点

	- 获取模块

		- 获取模块信息，下载模块之前先确定版本号

			- 存在锁定文件则从锁定文件中取
			- 不存在则根据版本号规则获取版本

				- ~：匹配小版本
				- ^：匹配大版本
				- *：安装最新版本

		- 获取模块实体，根据模块的压缩包地址，npm会取本地缓存中查找，如果存在则直接取，否则从仓库中下载
		- 查找该模块的依赖，递归上述过程

	- 模块扁平化

		- 上述第3部获取到的是一颗完整的依赖树，其中包含大量的重复模块，因此需要npm提供deduqe操作，逐个的将每个模块放入根节点下面，如果存在重复则丢弃

			- 重复模块

				- 模块名称相同且semver兼容
				- semver兼容 - 每个semver都对应一段版本允许范围，如果两个版本在这个允许范围中存在交集，则可以认为是一个兼容版本。

	- 安装模块

		- 更新项目中的node_modules目录，执行模块中的生命周期函数（postinstall）

	- 执行项目中自身的生命周期方法

		- 按照 install、postinstall、prepublish、prepare 的顺序，如果定义的话。

### 组件的设计

- 设计原则

	- 标准性

		- 遵守一套标准

	- 独立性

		- API对外开放，组件内部状态对外封闭，尽可能的少与业务耦合

	- 复用与易用

		- UI差异，消化在组件内部
		- 输入输出友好，易用

	- 追求短小精悍
	- 尽量不要重复代码
	- 避免暴露组件内部实现
	- 避免直接操作DOM，避免使用ref

		- 使用父组件的 state 控制子组件的状态而不是直接通过 ref 操作子组件

	- 入口处检查参数的有效性，出口处检查返回的正确性
	- 无环依赖原则(ADP)
	- 稳定抽象原则(SAP)
	- 避免冗余状态
	- 良好的接口设计

- 组件分类

	- 基础组件
	- 容器型组件
	- 展示型组件
	- 业务组件
	- 通用组件

		- UI组件
		- 逻辑组件

	- 高阶组件

### Git

- rebase

	- 将一个分支的更改并入到另外一个分支中去
	- 特点

- cherry-pick

	- 将一个分支的提交移植到另外一个分支

- 分支模型

	- git add

		- 为每一个文件计算一个校验和
		- 将当前版本的文件快照保存到Git仓库

			- blob 对象（保存着文件快照）

		- 将校验和加入到暂存区域等待提交

	- git commit

		- 计算每个子目录的校验和
		- 在GIt仓库中将这些校验和保存为树对象

			- 记录着目录结构和 blob 对象索引

		- 创建一个提交对象

			- 包含着指向前述树对象的指针和所有提交信息

	- 分支

		- 本质上仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。
		- master 分支会在每次提交时自动向前移动。

	- 分支创建

		- 创建了一个可以移动的新的指针

	- Git 又是怎么知道当前在哪一个分支上呢？ 

		- 有一个名为 HEAD 的特殊指针，指向当前所在的本地分支
		- git log --oneline --decorate

			- 查看 HEAD 指向当前所在的分支

	- checkout 

		- 新建分支

	- 分支合并

		- merge 

- 远程分支

	- git clone

		- 当在本地机器执行该命令时，会在本地给我们自动创建一个名origin/master的执行远程分支的指针
		- 每次执行拉取命令时origin/master指针会自动向前移动，使其与服务器的指向保持一致

	- git fetch

		- 从远程中同步本地没有的数据，并更新本地服务器，更新origin/master的指向
		- 不会改变工作目录中的内容，需要手动进行合并

	- git pull

		- 等价于执行git fetch后接着执行git merge

- merge

	- 将分支 feature 合并到分支 master

		- 将分支切换到 master 上去：git checkout master
		- 将分支 feature 合并到当前分支（即 master 分支）上：git merge feature

	- 特点

		- 只处理一次冲突
		- 在master分支上会多出一次提交记录，合并后的所有 commit 会按照提交时间从旧到新排列

	- 将两个分支的最新快照和最近祖先进行三方合并，生成一个新的快照

- rebase

	- 原理

		- 先找到两个分支的共同最近祖先
		- 然后对比当前分支相对于该祖先的历次提交，提取相应的修改并保存为临时文件
		- 将当前分支指向需要合入分支的最新快照
		- 依次将第二步的临时文件应用在当前分支

	- 特点

		- 提交历史是一条直线，没有分叉

	- --onto 选项

		- git rebase --onto master server client

			- 取出 client 分支，找出它从 server 分支分歧之后的补丁， 然后把这些补丁在 master 分支上重放一遍，让 client 看起来像直接基于 master 修改一样

	- git rebase <basebranch> <topicbranch>

		- 子主题 1

- 与其他版本控制的区别

	- 对待数据的方式？

		- 对当时的全部文件创建快照并保存快照索引

- git三种状态

	- 已提交（committed）
	- 已修改（modified）
	-  已暂存（staged）

- 三个阶段

	- 工作区

		- 编写代码的地方

	- 暂存区

		- 是一个文件，保存了下次将要提交的文件列表信息，一般在 Git 仓库目录中
		- .git目录下的index文件

	- 本地仓库

		- 保存项目的元数据和对象数据库的地方
		- 工作区目录下的.git目录

- 历史

	- git log

		-  -p 或 --patch

			- 显示每次提交所引入的差异

		- --pretty

			- oneline

				- 将每个提交放在一行显示

			- short，full 和 fuller 选项
			- format

				- 定制记录的显示格式

					- git log --pretty=format:"%h - %an, %ar : %s"

- 撤消

	- amend

		- 会将暂存区中的文件提交
		- git commit --amend

	- reset

		- git reset HEAD <file>... 来取消暂存

	- checkout

		- git checkout -- <file>...撤消之前所做的修改

			- Git 会用最近提交的版本覆盖掉

- 远程仓库

	- fetch

		- git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作

	- clone

		- 克隆仓库，自动将其添加为远程仓库并默认以 “origin” 为简写

	- push

		- 推送到远程仓库
		- git push <remote> <branch>

## 性能优化

### 6个性能指标

- FCP（First Contentful Paint）

	- 概念

		- 测量用户导航到页面后浏览器呈现第一段 DOM 内容所需的时间。 页面上的图像、非白色 <canvas> 元素和 SVG 被视为 DOM 内容； 不包括 iframe 内的任何内容。

	- 优化

		- 确保在 webfont 加载期间文本保持可见

			- 通过在 @font-face 样式中包含 font-display: swap，在加载字体过程中临时显示系统字体
			- 使用 <link rel="preload" as="font"> 提前获取字体文件

- TTI（Time to Interactive）

	- 衡量标准

		- 页面显示有用的内容
		- 为大多数可见的页面元素注册了事件处理程序
		- 该页面在 50 毫秒内响应用户交互

	- 优化

		- 最小化主线程工作
		- 减少JS的执行时间

- SI（Speed Index）

	- 速度指数衡量页面加载期间内容的视觉显示速度
	- 优化

		- 最小化主线程工作
		- 减少 JS 执行时间
		- 确保文本在 webfont 加载期间保持可见

- TBT（Total Blocking Time）

	- FID（First Input Delay）优化

		- 概念

			- 测量从用户第一次与页面进行交互到浏览器实际上能够响应该交互之间的时间
			- 可以通过Total Blocking Time (TBT)指标进行衡量
			- 在主线程中执行了大量的JS，导致用户的输入被阻塞

		- 优化

			- 将长任务拆分短任务

				- 长任务：阻塞主线程时间大于50毫秒的任务
				- 拆分长任务将代码分解为更小的异步任务

			- 进行页面优化

				- 分析第一个加载的JS的执行

					- JS太大、执行时间太长、不合理的分块都会导致JS执行慢，可以通过渐进式加载（惰性加载）执行代码

						- 延迟加载尽可能多的资源（JS、HTML、CSS），只有在用到是才进行加载
						- 给JS加上defer或async属性延迟加载
						- 给CSS加上media属性在满足条件的情况下加载资源
						- 图片加载

							- 使用Intersection Observer API

					- 使用基于路由的代码拆分

				- 获取数据方面的优化

					- 减少与客户端交互的数据量
					- 优化数据的嵌套层级，简化数据获取

				- 第三方JS的代码优化

					- 按需加载第三方提供的js

						- 比如，当折叠广告进入可视窗口时才去加载第三方提供的JS

					- 优先加载价值最大的JS代码

			- 使用web worker，运行非UI操作
			- 减少JS的执行时间

				- 减少页面中JS的数量

					- 延迟未使用的JS

						- 使用 Coverage tab页查看未使用的JS
						- 优化思路

							- 将大文件的JS代码拆分成多个chunks，然后通过ES6的import语法进行动态导入

								- import('module.js').then((module) => {
  // Do something with the module.
});

							- 使用anysc或defer延迟非关键的JS文件

					- 减少未使用的polyfills

						- 如果使用了babel进行代码转换，则应该使用@babel\preset-env仅包含需要的polyfills

		- 页面优化

			- lcp优化

				- 服务器的最慢响应时间

					- 浏览器从服务器接收内容所花费的时间越长，在屏幕上呈现任何内容所花费的时间就越长。

					  更快的服务器响应时间可以直接改善包括LCP在内的每个页面加载指标。
					  
					  
					- 首先，请改善服务器处理内容的方式和位置。 使用首字节时间（TTFB）来衡量服务器的响应时间

						- 优化服务器

							- 分析并提高服务器端代码的效率

						- 将内容托管到CDN服务器，引导客户端请求CDN的资源
						- 缓存静态的资源
						- 优先使用本地的缓存，如Service worker
						- 对于第三方来源的资源，需尽早建立第三方连接

							- <link rel="preconnect" href="https://example.com" />

							  使用preconnect告诉浏览器需要尽快建立连接
							  - <link rel="dns-prefetch" href="https://example.com" />
							  使用dns-prefetch尽快的进行DNS查询
							  
							  
						- 使用签名交换

							- 签名交换（SXG）是一种传递机制，它通过以易于缓存的格式提供内容来提供更快的用户体验。 具体来说，Google搜索将缓存并有时预取SXG。

				- 阻止渲染的JS和CSS

					- 减少CSS阻塞时间

						- 压缩CSS

							- 使用插件：optimize-css-assets-webpack-plugin 去掉CSS中的空格、缩进、注释等

						- 延迟非关键CSS

							- 首先，首页chrome开发者工具中的Coverage标签页找到没有使用的CSS
							- 接着，删除未使用的，或将其移除到其他CSS文件中
							- 使用异步加载非初始渲染必要的CSS文件

								- <link rel="preload" href="stylesheet.css" >

						- 内联关键CSS

							- 将关键路径的CSS包含在head中将其内联，可以减少往返请求以获取关键CSS的时间
							- 如果不能手动内联，可以使用critters-webpack-plugin插件进行内联

					- 减少JS阻塞时间

						- 优化方向

							- 最小提供必需的JS资源，减少阻塞JS数量

						- 缩小并压缩JS文件
						- 延迟未使用的JS
						- 尽量减少未使用的polyfills

					- 最慢资源加载时间

				- 资源加载时间

					- 类型

						- img元素
						- svg 元素内的 image 元素
						- video 元素
						- 通过url（）函数加载背景图片的元素
						- 包含文本节点或其他内联级文本元素的块级元素

					- 优化

						- 优化和压缩图像
						- 预加载重要资源

							- <link rel="preload" as="image" href="img.png" />

						- 压缩文本文件

							- 首先，检查服务器是否已经自动压缩文件。

						- 根据不同的网络情况提供不同的资产
						- 使用service worker缓存资产

				- 客户端渲染时间

					- 优化

						- 最小化关键JS

							- 缩小JS
							- 延迟未使用的JS
							- 尽量减少未使用polyfills

						- 使用服务器端渲染（Next.js）

							- 缺点

								- 会增加复杂性
								- 增加服务器响应时间（TTFB）
								- 会使互动时间（TTI）变差

						- 使用预渲染

					- 资料

					  https://web.dev/optimize-lcp/
					  https://web.dev/optimize-fid/
					  
					  *XMind - Trial Version*
					  
					  
- LCP（Largest Contentful Paint）

	- lcp（Largest Contentful Paint）优化

		- 概念

			- 可见视口内最大图像或文本块的渲染时间，相对于页面首次开始加载的时间。
			- 应该努力使时间小于等于2.5s
			- 元素类型

				- img元素
				- svg元素内的image元素
				- video元素
				- 通过URL加载的背景图片
				- 文本节点或包含其他内联级文本元素子级的块级元素

			- 元素大小的确定

				- 只计算视口内的大小，溢出、裁剪的忽略
				- 不考虑元素的margin、border、padding

		- 优化

			- 服务器的最慢响应时间

				- 浏览器从服务器接收内容所花费的时间越长，在屏幕上呈现任何内容所花费的时间就越长。

				  更快的服务器响应时间可以直接改善包括LCP在内的每个页面加载指标。
				  
				  
				- 首先，请改善服务器处理内容的方式和位置。 使用首字节时间（TTFB）来衡量服务器的响应时间

					- 优化服务器

						- 分析并提高服务器端代码的效率

					- 将内容托管到CDN服务器，引导客户端请求CDN的资源
					- 缓存静态的资源
					- 优先使用本地的缓存，如Service worker
					- 对于第三方来源的资源，需尽早建立第三方连接

						- <link rel="preconnect" href="https://example.com" />

						  使用preconnect告诉浏览器需要尽快建立连接
						  - <link rel="dns-prefetch" href="https://example.com" />
						  使用dns-prefetch尽快的进行DNS查询
						  
						  
					- 使用签名交换

						- 签名交换（SXG）是一种传递机制，它通过以易于缓存的格式提供内容来提供更快的用户体验。 具体来说，Google搜索将缓存并有时预取SXG。

			- 阻止渲染的JS和CSS

				- 减少CSS阻塞时间

					- 压缩CSS

						- 使用插件：optimize-css-assets-webpack-plugin 去掉CSS中的空格、缩进、注释等

					- 延迟非关键CSS

						- 首先，首页chrome开发者工具中的Coverage标签页找到没有使用的CSS
						- 接着，删除未使用的，或将其移除到其他CSS文件中
						- 使用异步加载非初始渲染必要的CSS文件

							- <link rel="preload" href="stylesheet.css" >

					- 内联关键CSS

						- 将关键路径的CSS包含在head中将其内联，可以减少往返请求以获取关键CSS的时间
						- 如果不能手动内联，可以使用critters-webpack-plugin插件进行内联

				- 减少JS阻塞时间

					- 优化方向

						- 最小提供必需的JS资源，减少阻塞JS数量

					- 缩小并压缩JS文件
					- 延迟未使用的JS
					- 尽量减少未使用的polyfills

				- 最慢资源加载时间

			- 资源加载时间

				- 类型

					- img元素
					- svg 元素内的 image 元素
					- video 元素
					- 通过url（）函数加载背景图片的元素
					- 包含文本节点或其他内联级文本元素的块级元素

				- 优化

					- 优化和压缩图像
					- 预加载重要资源

						- <link rel="preload" as="image" href="img.png" />

					- 压缩文本文件

						- 首先，检查服务器是否已经自动压缩文件。

					- 根据不同的网络情况提供不同的资产
					- 使用service worker缓存资产

			- 客户端渲染时间

				- 优化

					- 最小化关键JS

						- 缩小JS
						- 延迟未使用的JS
						- 尽量减少未使用polyfills

					- 使用服务器端渲染（Next.js）

						- 缺点

							- 会增加复杂性
							- 增加服务器响应时间（TTFB）
							- 会使互动时间（TTI）变差

					- 使用预渲染

				- 资料

				  https://web.dev/optimize-lcp/
				  https://web.dev/optimize-fid/
				  
				  *XMind - Trial Version*
				  
				  
- CLS（累积布局偏移）

	- 概念

		- 每当可见元素将其位置从一个渲染帧更改为下一个时，就会发生布局偏移
		- 衡量页面整个生命周期内发生的每个意外布局偏移的最大布局偏移分数的度量。

	- 优化

		- 没有尺寸的图像

			- 始终在图像和视频元素上包含宽度和高度大小属性
			- 使用 CSS 纵横比框保留所需的空间

		- 没有尺寸的广告

			- 为广告位静态预留空间
			- 避免在视口顶部附近放置广告

		- 嵌入和 iframe
		- 动画

			- 优先使用 transform 动画而不是properties 动画

		- 动态注入的内容

			- 避免在现有内容之上插入新内容，除非响应用户交互
			- 使用占位符或骨架 UI

### 工具

- lighthouse
- performance

### 前端性能优化之雅虎35条军规

- 服务器

	- 使用CDN
	- 使用浏览器缓存
	- 开启gzip
	- 配置Etag
	- 尽量使用Get请求，可以进行缓存
	- 避免图片src为空
	- 服务端渲染

- 页面内容

	- 减少HTTP数量
	- 减少DNS查询
	- 避免重定向
	- 缓存AJAX请求
	- 延迟加载
	- 预加载
	- 减少DOM数量
	- 不同内容划分到不同域名
	- 减少使用iframe
	- 减少404

- cookie

	- 减少cookie大小
	- 静态资源使用无cookie的域名

- 移动端

	- 保持单个文件小于25kb
	- 子主题 2

- 图片

	- 尽可能使用webp
	- 雪碧图

- JS 

	- script放底部
	- 使用外部JS和CSS
	- 压缩JS
	- 删除重复脚本
	- 减少DOM操作
	- 使用高效事件处理

- CSS

	- style放头部
	- 不要使用CSS表达式
	- 是有link代替@import
	- 不要使用IE中的filter

### 优化思路

- 网络层面

	- 构建策略

		- 减少打包时间

			- 缩减范围

				- 配置include/exclude缩小Loader对文件的搜索范围

			- 缓存副本

				- 配置cache缓存Loader对文件的编译副本

			- 定向搜索

				- 配置resolve提高文件的搜索速度

					- alias：指定映射模块路径
					- extensions：指定没有文件后缀时的后缀
					- noParse：不需要处理的文件

			- 提前构建

				- 配置DllPlugin将第三方依赖提前打包

			- 并行构建

				- 配置Thread将Loader单进程转换为多进程

					- thread-loader

			- 分析结构

				- 配置webpack-bundle-analyzer分析打包文件结构，找出导致体积过大的原因

		- 减少打包体积

			- 分割代码

				- 分割各个模块代码，提取相同部分代码，减少重复代码的出现频率

					- splitChunks

			- 摇树优化

				- 删除项目中未被引用代码，移除重复代码和未使用代码
				- 摇树优化只对ESM规范生效，对其他模块规范失效。摇树优化针对静态结构分析，只有import/export才能提供静态的导入/导出功能

			- 动态垫片
			- 按需加载

				- 将路由页面/触发性功能单独打包为一个文件，使用时才加载，减轻首屏渲染的负担

					- 切割模块
					- import()加载

			- 作用提升

				- 分析模块间依赖关系，把打包好的模块合并到一个函数中，减少函数声明和内存花销
				- 在未开启作用提升前，构建后的代码会存在大量函数闭包。由于模块依赖，通过webpack打包后会转换成IIFE，大量函数闭包包裹代码会导致打包体积增大(模块越多越明显)。

			- 压缩资源

				- 压缩HTML/CSS/JS代码，压缩字体/图像/音频/视频，更有效减少打包体积

					- html-webpack-plugin开启压缩功能。
					- OptimizeCss基于cssnano封装
					- Uglifyjs和Terser

	- 图像策略

		- 图像选型
		- 图像压缩

	- 分发策略

		- 所有静态资源走CDN

			- 静态资源包括哪些文件？

				- 通常来说就是无需服务器产生计算就能得到的资源
				- 不常变化的样式文件、脚本文件和多媒体文件(字体/图像/音频/视频)等

		- 把静态资源与主页面置于不同域名下

			- 避免请求带上Cookie

	- 缓存策略

		- 频繁变动资源

			- 设置Cache-Control:no-cache，使浏览器每次都发送请求到服务器，配合Last-Modified/ETag验证资源是否有效

		- 不常变化资源

			- 设置Cache-Control:max-age=31536000，对文件名哈希处理，当代码修改后生成新的文件名，当HTML文件引入文件名发生改变才会下载最新文件

- 渲染层面

	- CSS策略

		- 嵌套规则避免出现超过三层
		- 避免ID选择器添加其他选择器
		- 避免重复定义匹配规则
		- 避免使用通配选择器

	- DOM策略

		- 缓存DOM计算属性
		- 避免过多DOM操作
		- 使用DOMFragment缓存批量化DOM操作

	- 阻塞策略

		- defer、async

	- 回流重绘策略
	- 异步更新策略

## 监控

### 性能监控

### 异常监控

- 搜集上报

	- 搜集错误

		- try/catch

			- 能捕获常规运行时错误，不能捕获语法错误和异步错误

		- window.onerror

			- 能捕获常规运行时错误和异步错误，不能捕获语法错误

		- window.addEventListener

			- 图片、script、css加载错误，都能被捕获
			- new Image错误，不能捕获
			- fetch错误，不能捕获

		- unhandledrejection

			- 捕获Promise中的错误

		- 跨域脚本错误

- 采集聚合
- 可视分析
- 监控告警

## 数据结构和算法

## 框架

### angular

### vue

- MV*模式

	- MVC（Model-View-Controller）

		- View

			- 检测用户的键盘、鼠标等行为，传递调用Controller执行应用逻辑
			- View更新需要重新获取Model的数据

		- Controller

			- View和Model之间协作的应用逻辑或业务逻辑处理

		- Model

			- Model变更后，通过观察者模式通知View更新视图。

	- MVP（Model-View-Presenter）

		- Passive View

			- View从特定的业务场景中抽离，不再处理同步逻辑，因此可以做到组件化

		- Presenter

			- 处理应用业务逻辑
			- 处理同步逻辑

		- Model

			- Model变更后，通过观察者模式通知Presenter
			- 视图更新，Presenter调用View的接口更新视图。

	- MVVM（Model-View-ViewModel）

		- Model

			- Model的变化会被Binder监听

		-     View

			- View的变化会通过Binder自动更新相应的Model

		-     ViewModel

			- 内部集成数据绑定引擎，Binder则会实现View和Model的双向绑定，从而实现View或Model的自动更新

- 数据劫持（响应式数据原理）
- 事件绑定原理

	- 原生的事件绑定

		- 实现

			- 在普通元素上通过@click绑定
			- 在组件上通过@click.native绑定

		- 原理

			- 编译 template 模板，生成 AST 树

				- 对事件指令（v-on: | @）进行收集。

			- AST 转换成 render 函数

				- 普通元素：{on:{click:func}}，组件原生事件：{nativeOn:{click:func}}

			- 首次渲染，或者是更新都会执行createPatchFunction方法

				- 参数中会传入一个modules 字段，里面包含了一个events.create -- updateDOMListeners

				  ```
				  export const patch: Function = createPatchFunction({ nodeOps, modules })
				  
				  // web/runtime/modules/index
				  modules = [
				    ......
				    events,
				    ......
				  ]
				  
				  // events.js
				  export default {
				    create: updateDOMListeners,
				    update: updateDOMListeners
				  }
				  ```    
				  
				- 执行createElm创建元素
				- 调用invokeCreateHooks钩子即会调用updateDOMListeners方法

				  ```
				  function invokeCreateHooks (vnode, insertedVnodeQueue) {
				    for (let i = 0; i < cbs.create.length; ++i) {
				      // 其中一个即是 updateDOMListeners 方法
				      cbs.create[i](emptyNode, vnode)
				    }
				  }
				  ```
				  
				- updateDOMListeners方法会判断VNode中是否有事件，没有则return，否则给一个add方法

				  ```
				  function updateDOMListeners (oldVnode: VNodeWithData, vnode: VNodeWithData) {
				    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
				      return
				    }
				    const on = vnode.data.on || {}
				    const oldOn = oldVnode.data.on || {}
				    target = vnode.elm
				    updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context)
				    target = undefined
				  }
				  ```
				  
				- 在add方法中会调用目标对象的addEventListener方法进行事件绑定

				  ```
				  function add (
				    name: string,
				    handler: Function,
				    capture: boolean,
				    passive: boolean
				  ) {
				    target.addEventListener(
				      name,
				      handler,
				      supportsPassive
				        ? { capture, passive }
				        : capture
				    )
				  }
				  ``` 
				  
	- 组件的事件绑定

	  ```
	  <template>
	  　　 <child @updateInfo="updateInfo"/>
	  </template>
	  // updateInfo 在父组件中定义
	  
	  ```
	  
		- 实现

			- 通过自定义的$on实现，需要$emit触发

		- 原理

			- 组件实例化时调用initMixin中添加的_init方法
			- 如果是组件会进行组件信息初始化 - initInternalComponent
			- 组件初始化中主要获取父组件的`$listeners`事件
			- 初始化事件对象 - initEvents

			  ```
			  export function initEvents (vm: Component) {
			    // 保存自定义事件
			    vm._events = Object.create(null)
			    vm._hasHookEvent = false
			    // init parent attached events
			    const listeners = vm.$options._parentListeners
			    if (listeners) {
			      updateComponentListeners(vm, listeners)
			    }
			  }
			  ```
			  
			- 获取父组件给其绑定的事件进行绑定操作 - updateComponentListeners
			- 调用updateListeners传入add方法即$on

			  ```
			  updateListeners(listeners, oldListeners || {}, add, remove, createOnceHandler, vm)
			  
			  function add (event, fn) {
			    target.$on(event, fn)
			  }
			  ```
			  
- v-model的实现原理

	- value+input 方法的语法糖

- 生命周期

	- beforeCreate

		- 实例初始化之后，数据监测之前

	- created

		- 数据观测、属性和方法的运算完成后，可以进行一些数据、资源的请求

	- beforeMount
	- mounted

		- 实例已经挂载完成，可以进行一些DOM操作

	- beforeUpdated
	- updated
	- beforeDestroy
	- destroyed

		- 可以执行一些优化操作，清空计时器，解除绑定事件

- 编译原理

	- 将模版字符串解析成 ast
	- 标记静态节点
	- 生成 render 函数

- diff算法

  ```
  function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
      let oldStartIdx = 0
      let newStartIdx = 0
      let oldEndIdx = oldCh.length - 1
      let oldStartVnode = oldCh[0]
      let oldEndVnode = oldCh[oldEndIdx]
      let newEndIdx = newCh.length - 1
      let newStartVnode = newCh[0]
      let newEndVnode = newCh[newEndIdx]
      let oldKeyToIdx, idxInOld, vnodeToMove, refElm
  
      const canMove = !removeOnly
  
      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
        if (isUndef(oldStartVnode)) {
          oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
        } else if (isUndef(oldEndVnode)) {
          oldEndVnode = oldCh[--oldEndIdx]
        // 头头进行比较
        } else if (sameVnode(oldStartVnode, newStartVnode)) {
          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
          oldStartVnode = oldCh[++oldStartIdx]
          newStartVnode = newCh[++newStartIdx]
        // 尾尾进行比较
        } else if (sameVnode(oldEndVnode, newEndVnode)) {
          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
          oldEndVnode = oldCh[--oldEndIdx]
          newEndVnode = newCh[--newEndIdx]
        // 头尾进行比较
        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
          /**
           * 老节点列表： 1，2，3，4
           * 新节点列表： 2，3，4，1
           * 
           * 移动节点：将老节点列表的节点1，插入到老节点列表的结束节点的下一个节点之前
           * 
           */
          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);
          // 如果老节点列表的开始节点和新节点列表的结束节点相同，则说明节点需要向右移动
          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
          oldStartVnode = oldCh[++oldStartIdx]
          newEndVnode = newCh[--newEndIdx]
        // 尾头进行比较
        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
  
          /**
           * 老节点列表： 1，2，3，4
           * 新节点列表： 4，3，2，5
           * 
           * 移动节点：将老节点列表的老节点4，插入老节点4到老节点列表中开始标记之前
           */
          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
          oldEndVnode = oldCh[--oldEndIdx]
          newStartVnode = newCh[++newStartIdx]
        } else { // 交叉比较
  
          // 首先根据老节点列表生成子节点的key索引
          if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
  
          // 然后取新节点列表的起始节点的key，在老节点索引中查找
          idxInOld = isDef(newStartVnode.key)
            ? oldKeyToIdx[newStartVnode.key]
            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
          // 如果节点索引中不存在，说明是新节点，则进行节点创建
          if (isUndef(idxInOld)) { // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
          } else {
            vnodeToMove = oldCh[idxInOld]
            // 比较
            if (sameVnode(vnodeToMove, newStartVnode)) {
              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
              oldCh[idxInOld] = undefined
              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
            } else { // 如果key一样，当是不是相同节点，则直接创建新节点
              // same key but different element. treat as new element
              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
            }
          }
          newStartVnode = newCh[++newStartIdx]
        }
      }
      // 节点比对结束后，如果老节点列表的开始索引大于结束索引，则说明老节点列表先结束while循环，则需要将新节点列表中开始索引到结束索引这个期间的节点进行新增操作
      /**
       * 老节点列表： 1,2,3,4,5
       * 新节点列表： 1,2,3,4,5,6,7
       * 
       * newStartIdx指向6节点，newEndIdx指向7节点
       * 
       */
      if (oldStartIdx > oldEndIdx) {
        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
      // 如果新节点列表先结束while循环，则需要将老节点列表中开始索引到结束索引直接的节点进行删除操作
      } else if (newStartIdx > newEndIdx) {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
      }
  }
  ```
  
	- 同级比较
	- 首先新旧节点列表都会定义两个指针，分别指向它们的头节点和尾节点
	- 首先比较新节点列表的头节点和旧节点列表的头节点是否是一样的节点
	- 如果头头不一样则接着比较新节点列表的尾节点和旧节点列表的尾节点是否是一样的
	- 如果头头和尾尾不一样则进行新节点的头节点和旧节点的尾节点进行比较
	- 如果头头、尾尾、头尾都不一样，则比较新节点的尾节点和头节点进行比较
	- 头头、尾尾、头尾、尾头都不一样，则进行交叉比较

- computed / watch 实现的原理

	- Vue的实例化过程中响应式data数据处理后会处理computed属性 - 调用 initComputed 方法

		- 创建 Watcher 实例，添加一个 deps 数组，用于收集依赖此属性的 Watcher。

	- 初始化computed属性
	- 渲染watcher获取computed中的属性会调用给其绑定的computedGetter方法
	- computed对象在计算值的时候会调用依赖属性的set方法，该方法会将computed watcher加入到对应属性的观察Watcher数组中，当对应属性变化时会触发notify遍历每一个观察Watcher进行update

- 组件中的data为什么是函数

	- 避免组件中的数据互相影响。
	- 同一个组件被复用多次会创建多个实例，如果 data 是一个对象的话，这些实例用的是同一个构造函数。
	- 为了保证组件的数据独立，要求每个组件都必须通过 data 函数返回一个对象作为组件的状态。

- keep-alive

	- keep-alive 是 vue 的一个内置抽象组件，它自身不会渲染成一个 DOM元素，也不会出现在组件的父组件链中。
	- 用 keep-alive 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。
	- keep-alive 组件定义了 render 函数及created、destroyed、mounted三个生命周期函数

- $nextTick 的原理

	- JS执行时会生成一个 timerFunc

		- Promise（微任务）
		- MutationObserver（微任务）
		- setImmediate（宏任务）
		- setTimeout（宏任务）

	- Vue 数据变化时，需要更新界面，这时并不会直接更新DOM，而是开启一个队列，并缓存中同一个事件中发生的所有数据变更。
	- nextTick - 把回调函数放入一个callbacks队列，等待适当的时机执行

- 性能优化

	- 编码优化

		- 拆分组件
		- 防抖节流
		- key 保证唯一性
		- keep-alive
		- 路由懒加载、异步组件

	- Vue加载性能优化

		- 图片懒加载
		- 第三方模块按需导入（ babel-plugin-component ）

	- 用户体验

		- app-skeleton 骨架屏

	- SEO优化

- 路由模式

	- hash 模式

		- 使用URL 的hash作为路由
		- 原理

			- 监听 window.hashChange 事件，然后在回调中进行跳转

		- 发生变化的 URL 都会被浏览器记录下来

	- history 模式

		- HTML5 History API和服务器配置
		- 原理

			- 当点击浏览器前进、后退或调用跳转相关方法会触发window.onpopstate 事件

		- 刷新会请求服务器，需要服务端配合，不然容易出现404错误
		- 主要API

			- 跳转相关：go、back、forward
			- 修改相关：pushstate、replacestate

- 懒加载原理

	- vue 异步组件

		- 使用 resolve 的异步机制，用 require 代替 import 实现按需加载

	- es6 的 import()
	- webpack 的 require.ensure()

		- 通过 require.ensure(dependencies: String[], callback: function(require), chunkName: String) 将代码打包成不同的文件

### React

- 组件

	- React.Component

		- ES6 class语法定义的React组件的基类
		- 其他 API

			- setState()

				- setState(updater, [callback])

					- updater: (state, props) => stateChange

						- 基于之前的 state 来设置当前的 state
						- 不应直接被修改。你应该使用基于 state 和 props 构建的新对象来表示变化
						- updater 的返回值会与 state 进行浅合并。

					- callback

						- 在 setState 完成合并并重新渲染组件后执行，建议使用 componentDidUpdate() 来代替

				- setState(stateChange[, callback])

					- stateChange 会将传入的对象浅层合并到新的 state 中

				- setState() 并不总是立即更新组件。它会批量推迟更新

					- 调用 setState() 后立即读取 this.state 会存在问题

						- 使用 componentDidUpdate 或者 setState 的回调函数

			- forceUpdate()

				- component.forceUpdate(callback)

					- 强制让组件重新渲染

				- 默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。
				- 调用 forceUpdate() 将致使组件调用 render() 方法，会跳过该组件的 shouldComponentUpdate()。
				- 子组件会触发正常的生命周期方法

		- Class 属性

			- defaultProps

				- defaultProps 可以为 Class 组件添加默认 props
				- 一般用于 props 未赋值，但又不能为 null 的情况

			- displayName

				- displayName 字符串多用于调试消息

		- 实例属性

			- props

				- 包括被该组件调用者定义的 props
				- children 是一个特殊的 prop，通常由 JSX 表达式中的子组件组成，而非组件本身定义。

			- state

	- React.PureComponent

		- 与React.component的区别是实现了shouldComponentUpdate方法

			- 该方法实现浅层对比props和state

		- React.PureComponent 中的 shouldComponentUpdate() 将跳过所有子组件树的 prop 更新
		- 使用场景

			- 仅在 props 和 state 较为简单时，才使用 React.PureComponent
			- 在深层数据结构发生变化时调用 forceUpdate() 来确保组件被正确地更新

	- React.memo

		- 高阶组件

			- React.memo(MyComponent, areEqual);

		- 函数组件的优化：功能相当于 React.PureComponent，React.memo 仅检查 props 变更
		- 通过浅层比对 props 属性，如果相同则将跳过渲染组件的操作并直接复用最近一次渲染的结果 
		- 如果第一个参数是一个函数组件，且提供了useState，useReducer 或 useContext 的 Hook，当 context 发生变化时，它仍会重新渲染。
		- 默认情况下只会对复杂对象做浅层对比，可以通过提供第二个参数来自定义自己的比较规则：function areEqual(prevProps, nextProps) {/**/}

			- 与 class 组件中 shouldComponentUpdate() 方法区别

				- 如果 props 相等，areEqual 会返回 true；如果 props 不相等，则返回 false
				- shouldComponentUpdate() 返回值刚好相反

- 组件的生命周期

  https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
  
	- 挂载：组件实例被创建并插入 DOM 中

		- constructor()

		  ```
		  constructor(props) {
		    super(props);
		    // 不要在这里调用 this.setState()
		    this.state = { counter: 0 };
		    this.handleClick = this.handleClick.bind(this);
		  }
		  ```
		  
			- 用途

				- 通过给 this.state 赋值对象来初始化内部 state
				- 为事件处理函数绑定实例

			- 注意

				- 避免将 props 的值复制给 state

				  this.state = { color: props.color };
				  
				- 不要调用 setState() 方法

		- static getDerivedStateFromProps()

		  ```
		  static getDerivedStateFromProps(props, state)
		  ```
		  
			- getDerivedStateFromProps 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用
			- 此方法的适用场景？

				- state 的值在任何时候都取决于 props。
				- 组件在 props 变化时更新 state

			- 返回什么内容？

				- 返回一个对象来更新 state，如果返回 null 则不更新任何内容

			- 使用时的注意事项

				- 如果你需要执行副作用（例如，数据提取或动画）以响应 props 中的更改，请改用 componentDidUpdate
				- 如果只想在 prop 更改时重新计算某些数据，请使用 memoization helper 代替。
				- 如果你想在 prop 更改时“重置”某些 state，请考虑使组件完全受控或使用 key 使组件完全不受控 代替。

					- 受控组件

						- 不要直接复制 props 的值到 state 中，而是去实现一个受控的组件，然后在父组件里合并两个值。

						  ```
						  function EmailInput(props) {
						    return <input onChange={props.onChange} value={props.email} />;
						  }
						  ```
						  
					- 非受控组件

						- 使用 key 属性，重置内部所有的初始 state

						  ```
						  <EmailInput
						    defaultEmail={this.props.user.email}
						    key={this.props.user.id}
						  />
						  ```
						  
						- 仅更改某些字段，观察特殊属性的变化（比如 props.userID）。

						  ```
						  class EmailInput extends Component {
						    state = {
						      email: this.props.defaultEmail,
						      prevPropsUserID: this.props.userID
						    };
						  
						    static getDerivedStateFromProps(props, state) {
						      // 只要当前 user 变化，
						      // 重置所有跟 user 相关的状态。
						      // 这个例子中，只有 email 和 user 相关。
						      if (props.userID !== state.prevPropsUserID) {
						        return {
						          prevPropsUserID: props.userID,
						          email: props.defaultEmail
						        };
						      }
						      return null;
						    }
						  
						    // ...
						  }
						  ```
						  
							- 通过 getDerivedStateFromProps 观察变更的属性

						- 父组件使用 ref 调用子组件的实例方法

						  ```
						  class EmailInput extends Component {
						    state = {
						      email: this.props.defaultEmail
						    };
						  
						    resetEmailForNewUser(newEmail) {
						      this.setState({ email: newEmail });
						    }
						  
						    // ...
						  }
						  ```
						  
		- render()
		- componentDidMount()

			- 组件挂载后（插入 DOM 树中）立即调用
			- 用途

				- 初始化依赖于 DOM 节点的操作，如网络请求获取数据
				- 添加订阅，注意在 componentWillUnmount() 里取消订阅

			- 注意

				- 调用 setState()，会导致性能问题。通常，你应该在 constructor() 中初始化 state。

	- 更新：组件的 props 或 state 发生变化时

		- static getDerivedStateFromProps()
		- shouldComponentUpdate()

		  ```
		  shouldComponentUpdate(nextProps, nextState)
		  ```
		  
			- 根据 shouldComponentUpdate() 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。默认行为是 state 每次发生变化组件都会重新渲染。
			- 当 props 或 state 发生变化时，shouldComponentUpdate() 会在渲染执行之前被调用
			-  shouldComponentUpdate() 返回 false，则不会调用 render()，React 会跳过更新
			- 注意事项

				- 首次渲染或使用 forceUpdate() 时不会调用该方法
				- 仅作为性能优化的方式而存在，你应该考虑使用内置的 PureComponent 组件，而不是手动编写 shouldComponentUpdate()。

					- PureComponent 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。

		- render()
		- getSnapshotBeforeUpdate()

		  ```
		  class ScrollingList extends React.Component {
		    constructor(props) {
		      super(props);
		      this.listRef = React.createRef();
		    }
		  
		    getSnapshotBeforeUpdate(prevProps, prevState) {
		      // 我们是否在 list 中添加新的 items ？
		      // 捕获滚动​​位置以便我们稍后调整滚动位置。
		      if (prevProps.list.length < this.props.list.length) {
		        const list = this.listRef.current;
		        return list.scrollHeight - list.scrollTop;
		      }
		      return null;
		    }
		  
		    componentDidUpdate(prevProps, prevState, snapshot) {
		      // 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，
		      // 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。
		      //（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）
		      if (snapshot !== null) {
		        const list = this.listRef.current;
		        list.scrollTop = list.scrollHeight - snapshot;
		      }
		    }
		  
		    render() {
		      return (
		        <div ref={this.listRef}>{/* ...contents... */}</div>
		      );
		    }
		  }
		  ```
		  
			- getSnapshotBeforeUpdate() 在最近一次渲染输出（提交到 DOM 节点）之前调用
			- 用途

				- 组件能在发生更改之前从 DOM 中捕获一些信息，将作为参数传递给 componentDidUpdate()
				- 如需要以特殊方式处理滚动位置的聊天线程

		- componentDidUpdate()

			- 更新后会被立即调用。首次渲染不会执行此方法。
			- 用途

				- 进行 DOM 操作
				- 调用 setState()，必须被包裹在一个条件语句里避免死循环

			- 第三个参数 “snapshot” 是getSnapshotBeforeUpdate() 生命周期的返回值

	- 卸载：组件从 DOM 中移除

		- componentWillUnmount()

			- 组件卸载及销毁之前直接调用
			- 用途

				- 执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 componentDidMount() 中创建的订阅
				- 不应调用 setState()

	- 错误处理：渲染过程，生命周期，或子组件的构造函数中抛出错误

		- static getDerivedStateFromError()

			- static getDerivedStateFromError(error)
			- 会在后代组件抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state

		- componentDidCatch()

			- componentDidCatch()
			- 在“提交”阶段被调用
			- 用途

				- 执行副作用，用于记录错误

			- 开发和生产构建版本差别

				- 在开发模式下，错误会冒泡至 window
				- 生产模式下，错误不会冒泡

- 创建 React 元素

	- createElement()

		- React.createElement(type, [props], [...children])
		- 调用的结果？

			- 创建并返回指定类型的新 React 元素

		- type可以是普通标签、React组件、React Fragment 组件
		- JSX语法最终将转换成该函数

	- createFactory()

		- React.createFactory(type)
		- 返回用于生成指定类型 React 元素的函数
		- type可以是普通标签、React组件、React Fragment 组件

- 转换元素

	- cloneElement()

		- React.cloneElement(element,[props], [...children])
		- 调用的结果？

			- 以 element 元素为样板克隆并返回新的 React 元素

		- 返回元素的 props 是将新的 props 与原始元素的 props 浅层合并后的结果。

	- isValidElement()

		- React.isValidElement(object)
		- 验证object是否是一个React组件

	- React.Children

		- 提供处理this.props.children的一些方法
		- React.Children.map

			- React.Children.map(children, function[(thisArg)])
			- 与Array中的map区别？

				- 参数children可以是null或者undefined

			- 如果children是一个Fragment元素则被当做一个元素处理

		- React.Children.forEach

			- React.Children.forEach(children, function[(thisArg)])

		- React.Children.count
		- React.Children.only
		- React.Children.toArray

- Fragments

	- React.Fragment

		- 包装多个元素成一个元素
		- 简写：<></>

- Refs

	- 作用

		- Refs 提供了一种方式，允许我们访问 DOM 节点或在 render 方法中创建的 React 元素。
		- 持有子组件或元素的引用

	- 适合使用 refs 的情况

		- 管理焦点，文本选择或媒体播放
		- 触发强制动画
		- 集成第三方 DOM 库

	- 相关API

		- React.forwardRef

			- React.forwardRef((props, ref) => {/*返回渲染函数*/})
			- 根据参数函数创建一个React组件，并接收调用组件时传入的ref值，并把其赋值给参数函数的第二个ref参数
			- 使用场景

				- 转发 refs 到 DOM 组件

					- 将 ref 自动地通过组件传递到其一子组件
					- 使用步骤

						- 调用组件的地方通过调用 React.createRef 创建了一个 React ref 并将其赋值给 ref 变量
						- 通过指定 ref 为 JSX 属性，将其向下传递给 <FancyButton ref={ref}>
						- 子组件内部通过调用 React.forwardRef 方法 React 传递 ref 给 forwardRef 内函数 (props, ref) => ...，作为其第二个参数
						- 向下转发该 ref 参数到 <button ref={ref}>，将其指定为 JSX 属性
						- 当 ref 挂载完成，ref.current 将指向 <button> DOM 节点

				- 在高阶组件中转发 refs

				  ```
				  function logProps(Component) {
				    class LogProps extends React.Component {
				      componentDidUpdate(prevProps) {
				        console.log('old props:', prevProps);
				        console.log('new props:', this.props);
				      }
				  
				      render() {
				  
				        const {forwardedRef, ...rest} = this.props;
				        // 将自定义的 prop 属性 “forwardedRef” 定义为 ref
				  
				        return <Component ref={forwardedRef} {...rest} />;    }
				    }
				  
				    // 注意 React.forwardRef 回调的第二个参数 “ref”。
				    // 我们可以将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”
				    // 然后它就可以被挂载到被 LogProps 包裹的子组件上。
				  
				    return React.forwardRef((props, ref) => {
				      return <LogProps {...props} forwardedRef={ref} />;
				    });}
				  ```
				  
					- 因为 ref 不是 prop 属性，所有 refs 将不会透传下去
					- 可以使用 React.forwardRef API 明确地将 refs 转发到内部的 FancyButton 组件
					- React.forwardRef 接受一个渲染函数，其接收 props 和 ref 参数并返回一个 React 节点

		- 创建 Refs

		  ```
		  class MyComponent extends React.Component {
		    constructor(props) {
		      super(props);
		  
		      this.myRef = React.createRef();  }
		    render() {
		  
		      return <div ref={this.myRef} />;  }
		  }
		  ```
		  
			- React.createRef

				- inputRef = React.createRef();
				- 承接React元素中ref参数的返回值

		- 访问 Refs

		  const node = this.myRef.current;
		  
		  
			- 可以在 ref 的 current 属性中被访问
			- ref引用在普通DOM元素上时current指向底层 DOM 元素

			  ```
			  class CustomTextInput extends React.Component {
			    constructor(props) {
			      super(props);
			      // 创建一个 ref 来存储 textInput 的 DOM 元素
			  
			      this.textInput = React.createRef();    this.focusTextInput = this.focusTextInput.bind(this);
			    }
			  
			    focusTextInput() {
			      // 直接使用原生 API 使 text 输入框获得焦点
			      // 注意：我们通过 "current" 来访问 DOM 节点
			  
			      this.textInput.current.focus();  }
			  
			    render() {
			      // 告诉 React 我们想把 <input> ref 关联到
			      // 构造器里创建的 `textInput` 上
			      return (
			        <div>
			          <input
			            type="text"
			  
			            ref={this.textInput} />        <input
			            type="button"
			            value="Focus the text input"
			            onClick={this.focusTextInput}
			          />
			        </div>
			      );
			    }
			  }
			  ```
			  
			- 当在class组件上时ref引用的current指向组件的挂载实例

			  ```
			  class AutoFocusTextInput extends React.Component {
			    constructor(props) {
			      super(props);
			  
			      this.textInput = React.createRef();  }
			  
			    componentDidMount() {
			  
			      this.textInput.current.focusTextInput();  }
			  
			    render() {
			      return (
			  
			        <CustomTextInput ref={this.textInput} />    );
			    }
			  }
			  ```
			  
			- 函数组件不能使用ref

				- 要在函数组件中使用 ref，你可以使用 forwardRef

				  ```
				  function CustomTextInput(props) {
				    // 这里必须声明 textInput，这样 ref 才可以引用它
				    const textInput = useRef(null);
				    function handleClick() {
				      textInput.current.focus(); 
				    }
				    return (
				      <div>
				        <input
				          type="text"
				          ref={textInput} />     
				       <input
				          type="button"
				          value="Focus the text input"
				          onClick={handleClick}
				        />
				      </div>
				    );
				  }
				  ```
				  
		- 将 DOM Refs 暴露给父组件

			- ref 转发

		- 回调 Refs

			- React 将在组件挂载时，会调用 ref 回调函数并传入 DOM 元素，当卸载时调用它并传入 null
			- 传递一个函数，函数中接受 React 组件实例或 HTML DOM 元素作为参数，以使它们能在其他地方被存储和访问

			  ```
			  class CustomTextInput extends React.Component {
			    constructor(props) {
			      super(props);
			  
			  
			      this.textInput = null;
			  
			      this.setTextInputRef = element => {
			        this.textInput = element;
			      };
			  
			      this.focusTextInput = () => {
			        // 使用原生 DOM API 使 text 输入框获得焦点
			        if (this.textInput) this.textInput.focus();
			      };  }
			  
			    componentDidMount() {
			      // 组件挂载后，让文本框自动获得焦点
			  
			      this.focusTextInput();  }
			  
			    render() {
			      // 使用 `ref` 的回调函数将 text 输入框 DOM 节点的引用存储到 React
			      // 实例上（比如 this.textInput）
			      return (
			        <div>
			          <input
			            type="text"
			  
			            ref={this.setTextInputRef}        />
			          <input
			            type="button"
			            value="Focus the text input"
			  
			            onClick={this.focusTextInput}        />
			        </div>
			      );
			    }
			  }
			  ```
			  
			- 内联函数的方式定义 ref 回调

				- 更新过程中它会被执行两次

					- 第一次传入参数 null，然后第二次会传入参数 DOM 元素。

- Suspense

	- React.lazy

	  ```
	  // 这个组件是动态加载的
	  const SomeComponent = React.lazy(() => import('./SomeComponent'));
	  ```
	  
		- 定义一个动态加载的组件，有助于缩减 bundle 的体积，并延迟加载在初次渲染时未用到的组件。
		- 参数是什么？

			- React.lazy 接受一个函数，这个函数需要动态调用 import()

		- 返回值是什么？

			- 必须返回一个 Promise，该 Promise 需要 resolve 一个 default export 的 React 组件

		- 加载需要做什么？

			- 需要配合组件渲染树上层的 <React.Suspense> 组件一起使用，可以使用在等待加载 lazy 组件时做优雅降级（如 loading 指示器等）。

	- React.Suspense

	  ```
	  import React, { Suspense } from 'react';
	  
	  const OtherComponent = React.lazy(() => import('./OtherComponent'));
	  const AnotherComponent = React.lazy(() => import('./AnotherComponent'));
	  
	  function MyComponent() {
	    return (
	      <div>
	        <Suspense fallback={<div>Loading...</div>}>
	          <section>
	            <OtherComponent />
	            <AnotherComponent />
	          </section>
	        </Suspense>
	      </div>
	    );
	  }
	  ```
	  
		- 加载指示器，确保动态加载的组件已经加载完成
		- fallback 属性接受任何在组件加载过程中你想展示的 React 元素

- Context

  ```
  // Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。
  // 为当前的 theme 创建一个 context（“light”为默认值）。
  const ThemeContext = React.createContext('light');class App extends React.Component {
    render() {
  
      // 使用一个 Provider 来将当前的 theme 传递给以下的组件树。
      // 无论多深，任何组件都能读取这个值。
      // 在这个例子中，我们将 “dark” 作为当前的值传递下去。    return (
  
        <ThemeContext.Provider value="dark">        <Toolbar />
        </ThemeContext.Provider>
      );
    }
  }
  
  
  // 中间的组件再也不必指明往下传递 theme 了。
  function Toolbar() {  return (
      <div>
        <ThemedButton />
      </div>
    );
  }
  
  class ThemedButton extends React.Component {
  
    // 指定 contextType 读取当前的 theme context。
    // React 会往上找到最近的 theme Provider，然后使用它的值。
    // 在这个例子中，当前的 theme 值为 “dark”。  static contextType = ThemeContext;
    render() {
  
      return <Button theme={this.context} />;  }
  }
  ```
  
	- Context是什么

		- Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法
		- Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。

	- 何时使用 Context

		- Context 设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言。
		- 使用 context, 我们可以避免通过中间元素传递 props

	- 使用 Context 之前的考虑

		- 如果你只是想避免层层传递一些属性，组件组合（component composition）有时候是一个比 context 更好的解决方案。
		- 在组件树中很多不同层级的组件需要访问同样的一批数据。Context 能让你将这些数据向组件树下所有的组件进行“广播”，所有的组件都能访问到这些数据，也能访问到后续的数据更新。

	- API

		- React.createContext

		  ```
		  const MyContext = React.createContext(defaultValue);
		  ```
		  
			- 根据参数  defaultValue 创建一个 Context 对象
			- 只有当组件所处的树中没有匹配到 Provider 时，其 defaultValue 参数才会生效。

		- Context.Provider

		  ```
		  <MyContext.Provider value={/* 某个值 */}>
		  ```
		  
			- 每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化。
			- Provider 接收一个 value 属性，传递给消费组件。
			- 当 Provider 的 value 值发生变化时，它内部的所有消费组件都会重新渲染。

		- Class.contextType

		  ```
		  class MyClass extends React.Component {
		    componentDidMount() {
		      let value = this.context;
		      /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */
		    }
		    componentDidUpdate() {
		      let value = this.context;
		      /* ... */
		    }
		    componentWillUnmount() {
		      let value = this.context;
		      /* ... */
		    }
		    render() {
		      let value = this.context;
		      /* 基于 MyContext 组件的值进行渲染 */
		    }
		  }
		  MyClass.contextType = MyContext;
		  ```
		  
			- 给class的ContextType挂载上React.createContext创建的Context对象，然后class组件内部可以通过this.context访问到

		- Context.Consumer

		  ```
		  <MyContext.Consumer>
		    {value => /* 基于 context 值进行渲染*/}
		  </MyContext.Consumer>
		  ```
		  
			- 一个 React 组件可以订阅 context 的变更，此组件可以让你在函数式组件中可以订阅 context。

		- Context.displayName

			- context 对象接受一个名为 displayName 的 property，类型为字符串。

- Hook

	- 用途

		- 函数组件中可以使用React的一些特性

			- 在函数组件里“钩入” React state 及生命周期等特性的函数

		- 组件之间复用状态逻辑
		- 将复杂的组件相互关联的部分拆分成更小的函数，而非按照生命周期划分

	- 使用规则

		- 只能在函数最外层调用 Hook。不要在循环、条件判断或者子函数中调用。

			- 确保 Hook 在每一次渲染中都按照同样的顺序被调用

		- 只能在 React 的函数组件中调用 Hook。不要在普通 JavaScript 函数中调用。

			-  在 React 的函数组件中调用 Hook
			- 在自定义 Hook 中调用其他 Hook

	- 基础 Hook

		- useState

		  const [count, setCount] = useState(0);
		  
			- 调用 useState 方法的时候做了什么?

				- 定义了一个叫“count”的“state”变量
				- useState 是一种新方法，它与 class 里面的 this.state 提供的功能完全相同。

			- useState 需要哪些参数？

				- 初始state
				- 值可以是数字或字符串

			- useState 方法的返回值是什么？

				- 当前 state 以及更新 state 的函数

		- useEffect

		  ```
		  useEffect(() => {
		      function handleStatusChange(status) {
		        setIsOnline(status.isOnline);
		      }
		      ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
		      // Specify how to clean up after this effect:
		      return function cleanup() {
		        ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
		      };
		  });
		  ```
		  
			- useEffect 做了什么？

				- 告诉 React 组件需要在渲染后执行某些操作。
				- React 会保存你传递的函数（我们将它称之为 “effect”），并在执行 DOM 更新之后调用它。

			- 为什么在组件内部调用 useEffect？

				- 可以在 effect 中直接访问 count state 变量（或其他 props）

			- useEffect 会在每次渲染后都执行吗？

				- 默认情况下，它在第一次渲染之后和每次更新之后都会执行。

			- useEffect 需要哪些参数？

				- 副作用操作的一个函数
				- 可选的数组

					- 如果数组是一个空数组，则effect只会执行一次
					- 非空则只有当内容发生变化才会触发回调

			- useEffect 方法的返回值是什么？

				- 如果没有返回值则表示无需要清除的副作用
				- effect 返回一个函数，表示有需要清除的副作用，如订阅

			- React 何时清除 effect？

				-  React 会在组件卸载的时候执行清除操作
				- React 会在执行当前 effect 之前对上一个 effect 进行清除

		- useContext

		  const value = useContext(MyContext);
		  
		  
			- 调用 useContext方法的时候做了什么?

				- 读取 context 的值以及订阅 context 的变化
				- 当组件上层最近的 <MyContext.Provider> 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值

			- useContext需要哪些参数？

				- 一个 context 对象（React.createContext 的返回值）

			- useContext方法的返回值是什么？

				- 返回该 context 的当前值

	- 额外的 Hook

		- useReducer

		  ```
		  function init(initialCount) {
		    return {count: initialCount};
		  }
		  function reducer(state, action) {
		    switch (action.type) {
		      case 'increment':
		        return {count: state.count + 1};
		      case 'decrement':
		        return {count: state.count - 1};
		  
		      case 'reset':
		        return init(action.payload);    default:
		        throw new Error();
		    }
		  }
		  
		  function Counter({initialCount}) {
		  
		    const [state, dispatch] = useReducer(reducer, initialCount, init);  return (
		      <>
		        Count: {state.count}
		        <button
		  
		          onClick={() => dispatch({type: 'reset', payload: initialCount})}>        Reset
		        </button>
		        <button onClick={() => dispatch({type: 'decrement'})}>-</button>
		        <button onClick={() => dispatch({type: 'increment'})}>+</button>
		      </>
		    );
		  }
		  
		  ```
		  
			- useState 的替代方案，在某些场景下，useReducer 会比 useState 更适用

				-  state 逻辑较复杂且包含多个子值
				- 下一个 state 依赖于之前的 state 等
				- 使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 

			- useReducer 需要哪些参数？

				- 参数一：接收一个形如 (state, action) => newState 的 reducer
				- 参数二：指定初始 state

				  ```
				  const [state, dispatch] = useReducer(
				      reducer,
				      {count: initialCount}
				  );
				  ```
				  
				- 参数三：提供一个函数惰性地创建初始 state

					- 需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。

			- useReducer 方法的返回值是什么？

				- 返回当前的 state 以及与其配套的 dispatch 方法

			- 跳过 dispatch

				- 返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。

		- useCallback

		  ```
		  const memoizedCallback = useCallback(
		    () => {
		      doSomething(a, b);
		    },
		    [a, b],
		  );
		  ```
		  
			- useCallback 需要哪些参数？

				- 内联回调函数
				- 依赖项数组

			- 调用 useCallback 方法的时候做了什么?

				- 返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新

			- useCallback方法的返回值是什么？

				- 返回一个 memoized 回调函数。

			- 注意

				- 依赖项数组不会作为参数传给回调函数

		- useMemo

		  ```
		  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
		  ```
		  
		  
			- useMemo需要哪些参数？

				- “创建”函数
				- 依赖项数组

			- 调用 useMemo方法的时候做了什么?

				- 把参数传给useMemo后，仅会在某个依赖项改变时才重新计算 memoized 值。避免在每次渲染时都进行高开销的计算。
				- 传入 useMemo 的函数会在渲染期间执行
				- 如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值

			- useMemo 方法的返回值是什么？

				- 返回一个 memoized 值。

			- 注意

				- 依赖项数组不会作为参数传给“创建”函数。

		- useRef

		  ```
		  function TextInputWithFocusButton() {
		    const inputEl = useRef(null);
		    const onButtonClick = () => {
		      // `current` 指向已挂载到 DOM 上的文本输入元素
		      inputEl.current.focus();
		    };
		    return (
		      <>
		        <input ref={inputEl} type="text" />
		        <button onClick={onButtonClick}>Focus the input</button>
		      </>
		    );
		  }
		  ```
		  
		  
			- useRef需要哪些参数？

				- 一个初始化值，用于初始化返回值ref的current属性

			- 调用 useRef方法的时候做了什么?

				- useRef 会在每次渲染时返回同一个 ref 对象

			- useRef方法的返回值是什么？

				- useRef 返回一个在组件的整个生命周期内持续存在的可变的 ref 对象

		- useImperativeHandle

		  ```
		  function FancyInput(props, ref) {
		    const inputRef = useRef();
		    useImperativeHandle(ref, () => ({
		      focus: () => {
		        inputRef.current.focus();
		      }
		    }));
		    return <input ref={inputRef} ... />;
		  }
		  FancyInput = forwardRef(FancyInput);
		  ```
		  
		  
			- useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值
			- useImperativeHandle 应当与 forwardRef 一起使用

		- useLayoutEffect

			- 函数签名与 useEffect 相同
			- 会在所有的 DOM 变更之后同步调用 effect，可以使用它来读取 DOM 布局并同步触发重渲染。
			- 尽可能使用标准的 useEffect 以避免阻塞视觉更新。
			- useLayoutEffect 与 componentDidMount、componentDidUpdate 的调用阶段是一样的

		- useDebugValue

	- 自定义 Hook

		- 定义一个以“use”开头的 Hook 函数，函数内部可以调用其他 Hook

- 合成事件（SyntheticEvent）

	- 事件的传播过程

		- 事件捕获阶段
		- 目标阶段
		- 事件冒泡阶段

	- 事件委托

		- 通过事件冒泡，在父节点中通过e.target来捕获子节点的事件

			- 减少内存开销
			- 简化注册步骤

	- React 事件系统

		- 采用了事件委托思想，将具体的DOM事件统一冒泡到document上进行统一处理。
		- React对原生事件进行包装成合成事件然后进行分发。

- 性能优化

	- 虚拟化长列表
	- 覆盖 shouldComponentUpdate 方法

- Portals

  ReactDOM.createPortal(child, container)
  
  
	- 目的

		- 将子节点渲染到存在于父组件以外的 DOM 节点

	- 需要那些参数？

		- child：可渲染的 React 子元素
		- container：React子元素被渲染到那个 DOM 元素下

- render prop

  ```
  <DataProvider render={data => (
    <h1>Hello {data.target}</h1>
  )}/>
  ```
  
	- 介绍

		- 一种共享代码的简单技术： 通过给 React 组件的prop指定函数的方式
		- 具有 render prop 的组件接受一个返回 React 元素的函数，并在组件内部通过调用此函数来实现自己的渲染逻辑。
		- render prop 是一个用于告知组件需要渲染什么内容的函数 prop。

	- 使用说明

		- 不一定要用名为 render 的 prop 来使用这种模式。事实上， 任何被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”.

		  ```
		  <Mouse children={mouse => (
		    <p>鼠标的位置是 {mouse.x}，{mouse.y}</p>
		  )}/>
		  ```
		  
		- render prop 并不真正需要添加到 JSX 元素的 “attributes” 列表中。相反，你可以直接放置到元素的内部！

		  ```
		  <Mouse>
		    {mouse => (
		      <p>鼠标的位置是 {mouse.x}，{mouse.y}</p>
		    )}
		  </Mouse>
		  ```
		  
	- 注意事项

		- 与 React.PureComponent 一起使用

			- 在 render 方法里创建函数，浅比较 props 的时候总会得到 false，并且在这种情况下每一个 render 对于 render prop 将会生成一个新的值。
			- 解决方法？

				- 定义一个 prop 作为实例方法

- react-dom

	- render()

		- ReactDOM.render(element, container[, callback])

	- hydrate()
	- unmountComponentAtNode()

		- ReactDOM.unmountComponentAtNode(container)
		- 从 DOM 中卸载组件，会将其事件处理器（event handlers）和 state 一并清除

	- findDOMNode()

		- ReactDOM.findDOMNode(component)
		- 返回浏览器中相应的原生 DOM 元素
		- 可以绑定一个 ref 到 DOM 节点上，可以完全避免使用 findDOMNode

	- createPortal()

		- ReactDOM.createPortal(child, container)
		- portal提供一种将子节点渲染到 DOM 节点中的方式，该节点存在于 DOM 组件的层次结构之外。

*XMind - Evaluation Version*
